---
title: "What is the impact of inheritance on problem solving ability?"
author: "Pierce Edmiston"
abstract: |
  Does inheriting an existing solution to a problem simply give a head start on solving it or does it change the way the problem is solved? These experiments measure the impact of inheritance on problem solving ability. In the inheritance condition, one person works on a solution to a problem before passing it on to be inherited by the next person to continue. Because the people in this exchange are working together, I refer to them as **Diachronic teams**. This research compares the problem solving abilities of Diachronic teams organized around inheritance to other ways of allocating the same number of labor hours: Synchronic teams comprising individuals working in parallel and Isolated individuals working for the same total amount of time. Comparing the relative efficiencies of these three strategies will reveal the impact of inheritance on problem solving.
csl: "apa.csl"
bibliography: "diachronic-collaboration.bib"
output:
  html_document:
    theme: flatly
    css: style.css
    toc: true
    toc_depth: 2
    toc_float: true
---

```{r config, include = FALSE}
library(knitr)
library(printr)
library(magrittr)
library(crotchet)

opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE,
  results = "hide",
  fig.path = "totems-figs/",
  fig.width = 4,
  fig.height = 4,
  cache = TRUE,
  cache.path = ".cache.totems/"
)

list.files("R", "*.R", full.names = TRUE) %>% sapply(read_chunk)
```

```{r setup, cache = FALSE}
```

# Introduction

What is the impact of inheritance on problem solving ability? Does inheriting an existing or partial solution to a problem simply give a head start on solving it, or does it actually make for more effective problem solving? To answer this question I consider a simple form of inheritance where one person works on a solution to a problem and then passes it on to another person to continue. Does the person who inherits someone else's solution approach the problem differently as a result of the inheritance as compared to alternative ways of allotting the same number of labor hours (Fig. 1A)? By controlling the number of labor hours (rather than calendar hours, Fig. 1B), the effect of inheritance on problem solving is taken in proportion to the cost of generating the inheritance, and the cost in terms of individual learning (Fig. 1C).

```{r types-of-time, fig.width=8, fig.height=3, fig.cap="**Left panel.** Three strategies for allocating the same number of labor hours. The experimental condition is the **diachronic strategy** where members of a team work one at a time and pass the results on to the next generation. The other strategies are control conditions, comprising isolated individuals working alone and synchronic teams working in parallel. The other panels show the differences between these strategies along continuous dimensions of time. **Middle.** Relationship between labor hours and calendar hours. Labor hours are being controlled across the strategies, which forces diachronic and synchronic teams to differ in calendar hours. The rate at which labor hours are spent (per calendar hour) is the same for diachronic teams and isolated individuals. **Right.** Differences between teams in terms of time for individual learning. Isolated individuals have the most time for individual learning."}
```

The reason it's important to understand the impact of inheritance on problem solving is because inheritance is hypothesized to be one of the most important mechanisms of human cultural evolution, and yet we don't know it's impact on problem solving. The ability to propagate innovations across generations is foundational to the evolution of technology. Indeed, human cultures exhibit a ratcheting effect such that innovations are rarely lost, allowing improvements to accumulate even gradually and even without prior direction. By calling this process evolutionary, it is intended to imply that ordered i.e. non-random change may accumulate even through a random generation process. Human cultures are more equipped to capitalize on a lucky mutation than any form of biological evolution through sexual reproduction. However, this raises the question of whether human cultures succeed because they are able to retain even rare innovations or because they have the cognitive capacity to generate the innovations in the first place.

Many researchers in cultural evolution prioritize the role of cultural inheritance in explaining the survivability of individuals over individual intelligences. The basic idea is that cultures can retain generations of discovery such that without the influence of culture, many individuals simply wouldn't be able to survive, regardless of how intelligent they might be by today's standards. This perspective puts individual intelligence on a historical timescale: even if an individual was smart enough to rediscover on their own many of the things that might have been passed on from an ancestor, there simply wouldn't be enough time to do everything in a single lifetime. On this view the benefit to cumulative culture is that it gives people a head start on solving a problem without necessarily affecting underlying problem solving ability.

But there is also a sense in which new perspectives on a problem might be necessary in order to generate novel innovations. Eventually an individual working alone might get stuck and be unable to generate the necessary solution to a problem. In many cases, problem solvers can get fixated on particular ways of (incorrectly) solving a problem, and have difficulty seeing the problem with fresh eyes. In these cases, a new generation of problem solvers, might actually solve the problem more efficiency. This research is designed to elicit different trajectories through the same problem space, some achieved individually and some inherited from others. The critical test is whether inheritance can be a more efficient method for discovering problem solutions than alternative ways of allocating the same number of labor hours.

## Proposed mechanism

Inheritance is hypothesized to impact problem solving ability by starting the problem solver in a part of the problem space they otherwise might not have been likely to reach on their own. Whether or not this is helpful depends on the type of problem being solved. The type of problem that is hypothesized to benefit most from inheritance is a problem where progress is incrementally achieved. For problems that can't be solved incrementally, such as problems with binary or stochastic solutions, it's more difficult to measure the impact of inheritance because it's harder to know what can be gained from inheriting an incorrect solution that may not be any closer to the correct solution. For problems that allow for solutions to differ in degree of success, the impact of inheritance can be more precisely measured. Problems that can be solved incrementally are often open-ended, allowing many possible solutions, all varying in degree of success. Solutions to open-ended problems can be inherited and modified, but they can also be created by individuals working alone.

## Problem solving efficiency

I measure problem solving ability as efficiency in completing a problem in a specific amount of time. Problem solving research is often described as the set of cognitive abilities that enable the generation of problem solutions. Here I'm interested less in whether solutions can be generated and more in how efficiently progress is achieved. The goal of this research is to understand the impact of inheritance on problem solving efficiency.
\begin{equation}
problem\ solution = ability \times time = inheritance\\
problem\ solution_{additive} = inheritance + ability \times time\\
problem\ solution_{interactive} = inheritance \times ability \times time\\
\end{equation}

# Methods

<!-- Describe the problem space. -->

Participants play a computer game where they are given initial resources and tasked with combining the resources to generate new items (inventions). These inventions can then be combined to yield further inventions in pursuit of building a "sacred totem to appease the gods". More advanced inventions produce more intricate totems, and higher performance scores. For example, to build a totem, participants first needed to construct an axe out of three independently invented items: a refined stick used as a handle, a sharpened rock, and string wound from bark fibers (Fig. 2).

```{r sample-landscape, fig.width=8, fig.height=6}
```

## Participants

Participants are recruited until the final sample comprises 40 teams in each of the three strategy conditions for a total of 200 participants.

## Materials

Participants are tasked with a tool-building competition presented in a digital environment [@Derex:2015cbb]. Individuals combine resources and build ever more complicated tools in order to build "sacred totems to appease the gods". Individuals achieve high scores by traversing the innovation landscape and developing more and more elaborate ways of cutting, carving, and decorating their totems. A sample of the problem space is presented in Fig. 2.

## Procedure

```{r gameplay, fig.width=8, fig.height=6}
draw_image("gameplay", "totems")
```

# Two-person teams

```{r team-structures-exp1}
draw_graphviz("team-structures-exp1", "totems")
```

```{r data, echo = 1:4}
```

## Performance

```{r performance, include=FALSE}
```

There are multiple ways to assess performance. The performance measure shown here is the final number of inventions discovered by each team. Fig. 4 shows the accumulation of inventions over time in the three strategies. Results are similar for alternative performance metrics. My prediction was that inheritance in the diachronic teams would result in more efficient problem solving than the other strategies. Instead it appears there were not clear differences between the strategies. If anything, synchronic collaboration appears to be the most efficient way to solve this particular problem.

```{r fig4, fig.height=6, fig.width=8, fig.cap="**Problem solving performance by strategy**. The accumulation of inventions over time is shown on the left. On the right is final team performance. Synchronic collaboration is the most effective use of 50 labor minutes."}
grid.arrange(
  arrangeGrob(
    performance_over_time_plot,
    performance_stacked_plot + theme(legend.position = "none"),
    ncol = 1
  ),
  performance_plot,
  widths = c(0.6, 0.4)
)
```

### Model

```{r inventory-mod, echo=1}
inventory_mod <- lm(NumInnovations ~ Diachronic_v_Synchronic + Diachronic_v_Isolated,
                    data = TotemsTeams)
```

```{r inventory-results, results="asis"}
tidy(inventory_mod) %>%
  filter(term != "(Intercept)")
```

## Attempts

```{r attempts, include=FALSE}
```

One of the simplest ways to measure the influence of strategy on performance is to look at the total number of guesses made by participants and teams. If adopting a particular strategy for some reason spurs participants to guess at a faster rate, that strategy might improve final performance even if problem solving ability is unaffected.

```{r fig5, fig.width=6, fig.cap="**Individual and team attempts.** Isolated individuals make the most attempts, but they are given twice the amount of time. If attempts are totaled for all members of a team, synchronic collaboration results in the fastest guessing rate."}
attempts_plot
```

### Models

```{r attempts-mods, echo=1:2}
individual_attempts_mod <- lm(
  NumGuesses ~ Diachronic_v_Synchronic + Diachronic_v_Isolated,
  data = TotemsPlayers
)
team_attempts_mod <- lm(
  NumGuesses ~ Diachronic_v_Synchronic + Diachronic_v_Isolated,
  data = TotemsTeams
)
```

```{r attempts-results, results="asis"}
bind_rows(
  `Individual attempts` = tidy(individual_attempts_mod),
  `Team attempts` = tidy(team_attempts_mod),
  .id = "model"
) %>%
  filter(term != "(Intercept)")
```

```{r fig6, fig.width=6, fig.cap="**Team attempts predict number of inventions.** Teams that make more attempts tend to discover more inventions. Since synchronic teams make more attempts, they in turn discover more inventions."}
performance_by_attempts_plot
```

## Guessing efficiency

```{r efficiency, include=FALSE}
```

```{r fig7, fig.width=6, fig.cap="**Individuals are as inefficient as teams.** Although synchronic teamwork reduces the number of guesses per invention for individuals, the overall number of guesses per invention is about the same across the three strategies."}
efficiency_plot
```

### Models

```{r efficiency-mods, echo=1:2}
individual_efficiency_mod <- lmer(
  Guesses ~
    Diachronic_v_Synchronic + Diachronic_v_Isolated +
    (Diachronic_v_Synchronic + Diachronic_v_Isolated|TeamInventory) +
    NumInnovations +
    (1|TeamID/PlayerID),
  data = IndividualInventoryGuesses
)
team_efficiency_mod <- lmer(
  Guesses ~
    Diachronic_v_Synchronic + Diachronic_v_Isolated +
    (Diachronic_v_Synchronic + Diachronic_v_Isolated|TeamInventory) +
    NumTeamInnovations +
    (1|TeamID),
  data = TeamInventoryGuesses
)
```

```{r efficiency-results, results="asis"}
bind_rows(
  `Individual efficiency` = tidy(individual_efficiency_mod, effects = "fixed"),
  `Team efficiency` = tidy(team_efficiency_mod, effects = "fixed"),
  .id = "model"
) %>%
  filter(term != "(Intercept)")
```

## Redundant guesses

```{r redundancy, include=FALSE}
```

```{r fig8, fig.width=6, fig.cap="**Diachronic teams are the least redundant guessers.** Diachronic teams are less likely to repeat themselves than isolated individuals, and also less likely to repeat their teammate than synchronic teams. Synchronic teams are less likely to repeat an incorrect guess they guessed previously, but more likely to repeat a guess made by their partner."}
redundancy_plot
```

### Models

```{r redundant-mods, echo=1:2}
individual_redundancy_mod <- lmer(
  Redundancy ~ Diachronic_v_Synchronic + Diachronic_v_Isolated + (1|PlayerID),
  data = IndividualInventoryGuesses
)
team_redundancy_mod <- lmer(
  Redundancy ~ Diachronic_v_Synchronic + Diachronic_v_Isolated + (1|TeamID),
  data = TeamInventoryGuesses
)
```

```{r redundant-results, results="asis"}
bind_rows(
  `Individual redundancy` = tidy(team_redundancy_mod, effects = "fixed"),
  `Team redundancy` = tidy(individual_redundancy_mod, effects = "fixed"),
  .id = "model"
) %>%
  filter(term != "(Intercept)")
```

## Trajectories

```{r trajectories, include=FALSE}
```

```{r fig9}
trajectory_count_plot
```

# Four-person teams

```{r team-structures-exp2}
draw_graphviz("team-structures-exp2", "totems")
```

# Discussion

# References

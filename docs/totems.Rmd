---
title: "The impact of inheritance on problem solving ability"
author: "Pierce Edmiston, Max Derex, & Gary Lupyan"
abstract: |
  Human accumulate cultural products including tools and other technology like
  no other species of animal. A consequence of accumulating generations of
  solutions to problems is that new generations of problem solvers rarely have
  to start from scratch when solving new problems, as demonstrated by the
  widespread prevalence of reuse in the history of human technology. But what
  is the impact of inheritance---starting off a problem solving task with
  a partial solution that was created by someone else---on future problem
  solving ability? Does inheriting solutions discovered by a previous
  generation save time in future problem solving (linearly, and in proportion
  to the time that was invested in creating the inheritance), or does it affect the
  rate at which new problems are solved? To answer this question, we compared
  problem solving with inheritance to two alternative strategies for solving
  the same set of problems without inheritance. Critically, we compare the
  three strategies while controlling for total labor hours, so that the consequences
  of inheritance can be interpreted relative to the cost of creating it, and
  relative to the costs of not using an alternative problem solving strategy.
csl: "theme/apa.csl"
bibliography: "references.bib"
output:
  bookdown::html_document2:
    toc: yes
    toc_depth: 2
    toc_float: yes
    css: theme/style.css
    keep_md: yes
    number_sections: no
---
```{r totems, include=FALSE}
library(knitr)
library(crotchet)

opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE,
  results = "hide",
  dpi = 200,
  fig.width = 3,
  fig.height = 3,
  cache = TRUE
)

# Read all knitr chunks in files matching R/*.R
sapply(list.files("R", "*.R", full.names = TRUE), read_chunk)

# Read all the diagrams made with graphviz in the totems package
chunks <- c(
  "team-structures",
  "team-structures-all",
  "team-structures-exp1",
  "team-structures-exp2",
  "team-structures-exp3",
  "team-structures-exp4"
)
sapply(chunks, read_graphviz_chunk, package = "totems")
```

```{r setup, include=FALSE, cache=FALSE}
```

# Introduction

```{r intro, include=FALSE}
```

Humans are effective problem solvers. Part of this effectiveness comes from the
ability to reuse and adapt solutions to problems that were first created by
other people. Inventors rarely create inventions with no precursors, and
commonly use and adapt inventions that were first created by other people
[@Basalla:1989wq; @Valverde:2007fs] [cf. @Borner:2004dm]. But what do innovators
and other problem solvers gain from adapting solutions created by others? Do
problem solvers gain a head start on future problem solving, or does inheriting
an existing solution to a problem affect the way in which future problems are
solved?

This research investigates the impact of inheritance on problem solving ability
by studying the problem solving ability of individuals who inherit the solutions
created by a previous generation at the start of a problem solving task. This
type of collaboration, organized around inheritance, is referred to as
**diachronic collaboration** (Fig. \@ref(fig:team-structures)). To understand
how inheritance impacts problem solving ability, we compare the effectiveness of
diachronic collaboration to two alternative strategies for solving the same
problems in the same amount of time but without diachronic inheritance:
**synchronic collaboration**, where team members begin with nothing and
collaborate in parallel, and **isolated individuals**, given the most time for
individual learning (Fig. \@ref(fig:team-structures)). The purpose of this
comparison is to explore the impact of inheritance on problem solving by
comparing problem solving ability when starting with an inherited
solution---defined as diachronic problem solvers after the first generation---to
alternative strategies for solving the same problems without diachronic
inheritance.

(ref:team-structures) Problem solving strategies. Each node is a single problem
solver. Edge lengths represent labor hours spent solving a set of problems. In
diachronic collaboration, first generation problem solvers work on solutions to
problems before passing them on to be inherited by the next generation. The
impact of inheritance on problem solving is measured as the problem solving
ability of diachronic problem solvers after the first generation. Isolated
individuals do not inherit solutions from other problem solvers, but are given
the most time for individual learning. In synchronic collaboration, multiple
problem solvers work in parallel, sharing their progress, but synchronic teams
do not benefit from diachronic inheritance because all problem solvers
start from the same starting point.

```{r team-structures, engine="dot", fig.width=1.5, fig.cap="(ref:team-structures)"}
```

The synchronic and isolated strategies serve as control conditions in these
experiments: ways of solving the same set of problems without diachronic
inheritance. Synchronic and isolated problem solvers begin the problem solving
task at the same starting point, i.e. with no existing solutions. Only
diachronic problem solvers after the first generation inherit solutions from the
previous generation to learn from at the start of the experiment.

The diachronic condition will be referred to as the inheritance condition, but
other types of inheritance that do not influence the starting point of a problem
solver beginning a problem solving task are included in the control conditions.
Synchronic problem solvers share solutions with one another throughout the
problem solving task. What distinguishes diachronic and synchronic inheritance
is the time at which the solutions are shared. For diachronic problem solvers,
solutions are inherited once, at the start of the problem solving task. For
synchronic problem solvers, solutions are inherited intermittently, throughout
the task. A comparison of diachronic and synchronic problem solving (Exps. 2,4)
will reveal whether diachronic-generational or synchronic-intermittent
inheritance mechanisms result in more effective problem solving.

A third type of inheritance, individual inheritance, is introduced in Experiment
3. Individual inheritance is when the products of one's own problem solving are
resumed in independent problem solving sessions. Individual inheritance
involves inheriting from oneself, as opposed to inheriting from someone else.
Experiment 3 investigates how diachronic inheritance, the inheritance of partial
solutions at the start of a problem solving task, impacts problem solving
ability differently than an isolated individual, resuming problem solving in
subsequent sessions.

In order to fully understand the impact of inheritance on problem solving
ability, it is necessary to account for both the cost of creating the
inheritance as well as the consequences of inheritance on future problem
solving. In this study the cost and consequence of inheritance is controlled by
allotting a fixed number of labor hours to diachronic teams. The other
strategies investigated in this research are compared given the same number of
labor hours. Labor hours can be contrasted by two other measures of time that
are not controlled in these experiments: calendar hours and individual learning
hours (Fig. \@ref(fig:types-of-time)).

(ref:types-of-time) Types of time. **Left.** A key showing the problem solving
strategies for reference. See Fig. \@ref(fig:team-structures). **Middle.**
Relationship between calendar hours and labor hours. Synchronic collaboration
consumes a fixed amount of labor time more rapidly (per calendar hour) than
either the diachronic or isolated strategies. **Right.** Amount of individual
learning time in each strategy. An isolated strategy maximizes the amount of
time for individual learning relative to both diachronic and synchronic
strategies.

```{r types-of-time, fig.width=8, fig.height=3, fig.cap="(ref:types-of-time)"}
grid.arrange(
  read_graphviz("team-structures", "totems"),
  gg_time,
  gg_person,
  nrow = 1,
  widths = c(0.2, 0.4, 0.4)
)
```

# Methods

```{r methods, include=FALSE}
```

Participants solved as many problems as they could in a fixed amount of time. To
solve each problem, participants had to guess combinations of items that would
result in new items being created. The new items, created from combinations of
previous items, are referred to as innovations, and each innovation is the
solution to a single problem amid the larger set of problems in the problem
solving task. The context of the problem solving task is that participants are
accumulating innovations like axes, stone knives, and paintbrushes in service of
creating "a sacred totem pole to appease the gods." As participants accumulate
more complex innovations, they can then create more intricate and elaborate
totem poles, and receive higher performance scores as a result.

Participants were randomly assigned to either the diachronic condition (the
treatment condition) or one of the control conditions: isolated or synchronic.
Participants in the diachronic condition either participated as a first
generation problem solver, or began the problem solving task with the solutions
discovered by a previous generation. Each participant was assigned to a single
generation in a single team; the innovations of each diachronic problem solver
were only inherited by, at most, one future generation problem solver.

Participants in the synchronic condition collaborated in parallel via separate
computers. Team membership was not revealed to the participants either before or
after the experiment, and no interaction, other than through the computer
interface, was allowed. The only interaction that was allowed was the sharing of
innovations with all members of a synchronic team. Once an innovation was
discovered by a synchronic participant, the recipe for the creation of that
innovation became available for all members of the synchronic team.

Participants in the isolated condition participated in a single 50 minute
session, or alternately returned for four 25 minute sessions, spaced at least
one day apart. When isolated participants returned for later sessions, they
inherited the tools they had discovered in the previous session.

The data generated using these methods are reported in four experiments.
Experiment 1 investigates the result of accumulated inheritance over four
generations of diachronic problem solving. The analyses explore the differences
between first generation problem solvers and problem solvers who benefit from
inheritance, defined as diachronic problem solvers after the first generation.
In Experiment 2, we compare the simplest form of diachronic inheritance, a
two-person diachronic team, to a two-person synchronic strategy, and an isolated
individual given 50 minutes. In Experiment 3, diachronic inheritance from
someone else is compared to inheriting from oneself: isolated participants
returning for multiple sessions. Experiment 4 compares the three main strategies
(diachronic, isolated, and synchronic) given 100 minutes, including a
four-person synchronic strategy.

(ref:team-structures-all) All experimental conditions. The **Diachronic**
condition is the treatment condition: problem solving with inheritance. First
generation diachronic participants began without any previous solutions and
worked on the problem solving task for 25 minutes. Diachronic participants
assigned to generations 2-4 inherited the solutions discovered by the previous
generation at the start of the problem solving task. The two control conditions
were Isolated and Synchronic. **Isolated** participants either completed a
single 50 minute session, or returned for 4 subsequent 25 minute sessions. Upon
returning, these participants "inherited" the solutions they had created in the
previous session. **Synchronic** participants completed the problem solving task
in groups of 2 or 4 individuals, each participating for 25 minutes. Synchronic
participants collaborated in parallel, sharing solutions with all team members
as they were discovered.

```{r team-structures-all, engine="dot", fig.cap="(ref:team-structures-all)"}
```

## Materials and Procedure

**The Totems game**. Participants played a computer game, first reported in
@Derex:2015cbb, requiring players to iteratively solve problems related to
creating new tools out of existing items for the purposes of building "a sacred
totem to appease the gods." To build a totem, participants first needed to
construct an axe out of three independently discovered items: a refined stick
used as a handle, a sharpened rock for the blade, and string wound from bark
fibers for binding (Fig. \@ref(fig:landscape-sample)). In the game, more
advanced tools produce larger and more intricate totems, resulting in higher
performance scores.

(ref:landscape-sample) A sample of the solution landscape. The top row of 6
items are the initial resources available to problem solvers at the start of the
session. Resources must be combined to build the first generation of
innovations, including a refined rock, a club derived from an antler, and a
small branch of a tree. The first 6 generations of possible innovations are
shown. The axe is required to construct the first totem pole.

```{r landscape-sample, fig.cap="(ref:landscape-sample)"}
# draw_graphviz_with_images("landscape-sample", "totems")
draw_image("landscape-sample.gv", "totems")
```

**Guesses.** Participants solved problems by trial-and-error guessing of different
combinations of items they believed would yield new tools. To generate new
guesses, participants dragged items into a workshop panel (Fig.
\@ref(fig:interface)).

Of all the valid combinations of items that could be made, only a small
percentage successfully yielded new items. The 6 initial resources can be
combined with between 1 and 4 other items with replacement for a total of
`r count_unique_guesses(6)` unique guesses, only three of which
yield any new tools: a branch can be broken off a tree, an antler refined into
a club, and two rocks can be combined to yield a shaped stone. As the number
of items available to each problem solver increased, so did the combinatorial
complexity of the problem space. Thus, problems became more difficult
over time.

**Stock.** If a guess yielded an item, it could be stored in a stock panel. A maximum of 12
items could be stored in the stock panel at any given time. Items could be
discarded if space was needed in the stock panel for new items, or if an item
was not needed for any reason.

**Recipes.** Once an item was discovered, the recipe for its creation was recorded in the
history panel. Participants could review their item history and see the recipes
for their previous innovations, even items they had discarded.

In addition to an individual history, the history pane also had other tabs,
depending on which strategy each participant was assigned. Diachronic
participants after the first generation began with a tab that could be selected
to show all item recipes discovered by the previous generation. This was the way
in which solutions to previous problems were shared with future generations.
Isolated participants, if returning for multiple sessions, had a tab with the
solutions they had come up with during their previous session. Synchronic
participants had tabs for other synchronic problem solvers on their team.
The tab displayed the current score of each player, so synchronic were notified
that a discovery had been made by seeing a change in their teammates' score.

(ref:interface) The Totems gameplay interface. Participants generated guesses
by dragging items into the Workshop and selecting the Try button. If the guess
created an item, it could be dragged into the Stock panel, and used again. Once
segments of a totem were made through cutting, carving, and painting, they could be
dragged into the Totem panel for scoring.

```{r interface, fig.cap="(ref:interface)"}
draw_image("gameplay", "totems")
```

**Post experiment survey.** After the experiment was completed, participants
completed a brief post experiment survey assessing their understanding of the
task, their experience with games like the Totems game, and whether they used
any particular strategy for guessing.

## Participants

Participants (N=`n_recruited`) were students at the University of
Wisconsin-Madison who completed the experiment in exchange for course credit.
Students received credit for each completed session based on the duration of the
session, 25 minutes or 50 minutes. Participants in the Isolated, multi-session
experiment who completed all four sessions were awarded additional credit.

Participants were recruited until there were at least 40 teams in each strategy.
Most strategies, other than four-person synchronic teams, ended up receiving
more than 40 teams. The reason for this is that participants were scheduled in
groups of 4 participants at a time, and frequently one or more participants
would fail to show up for their extra credit opportunity. In these cases, the
remaining participants were run as a combination of diachronic and
two-person synchronic participants, resulting in a higher-than-expected
number of participants in those conditions.

Data from individual participants (N=`n_excluded`) were excluded from the final
analyses for the following reasons. Most of these (N=`n_errors`) were excluded
because they experienced errors in the computer game. Others
(N=`n_noncomplaint`) were noncomplaint, giving up on the problem solving task
(N=`n_gave_up`).

```{r counts-table, results="asis"}
kable(ConditionCounts, caption = "Total participant and team recruitment.")
```

# Experiment 1

```{r exp1, include=FALSE}
```

In the first experiment, we measured the impact of inheritance on problem
solving ability over four generations of diachronic problem solving (Fig.
\@ref(fig:team-structures-exp1)). We answer the following questions
about the impact of inheritance on problem solving. First, we
determine whether and by how much future generations of problem solvers were
able to recreate and exceed the solutions obtained by their ancestors. Second,
we test the relationship between the size of the inheritance and the rate at
which new problems, beyond those inherited, were solved. Finally, we determine
whether diachronic inheritance affects the way in which guesses are generated
by future generations of problem solvers.

(ref:team-structures-exp1) Diachronic problem solving strategy examined in
Experiment 1.

```{r team-structures-exp1, engine="dot", fig.cap="(ref:team-structures-exp1)"}
```

## Methods

Participants in the experiment either participated as a first generation problem
solver, or began the problem solving task with the solutions discovered by a
previous generation. Each participant was assigned to a single generation in a
single team; the unique innovations of each diachronic problem solver were
inherited by one (and only one) future generation problem solver.

### Participants

(ref:exp1-participants) Participants in Experiment 1.

```{r exp1-participants, results="asis"}
kable(Exp1Participants, caption = "(ref:exp1-participants)")
```

## Results

### Innovations by generation

Diachronic problem solvers were consistently able to exceed
the number of innovations discovered by their ancestors (Fig.
\@ref(innovations-by-generation)). The effect was linear over
generations, such that subsequent generations tended to discover
`r report_beta(innovations_by_generation_mod, "Generation")`
more innovations each generation,
`r report_lmer_mod(innovations_by_generation_mod, "Generation")`.

(ref:innovations-by-generation) Number of innovations discovered by each generation.

```{r innovations-by-generation, fig.cap="(ref:innovations-by-generation)"}
innovations_by_generation_plot
```

To determine whether later generation problem solvers were less effective
at exceeding their ancestors, we fit the same model with an
additional quadtratic term, but this additional parameter did
not significantly improve model fit, suggesting that fourth generation
problem solvers exceeded their ancestors to the same extent
that second generation problem solvers did.

This result is surprising because the overall difficulty of the
problem solving task, in terms of combinatorial complexity, would
suggest that later generation problem solvers, having inherited
more items, would also have a harder time generating new innovations,
in which case the number of innovations discovered by later generations
would be fewer than those discovered by previous generations.

To account for the increase in combinatorial complexity that results
from having more items to select from, we weighted each innovation
by its combinatorial difficulty.

Some slow down in problem solving rate is expected in this task.
As innovations are accumulated, the total number of possible guesses than can
be made increases exponentially, and so later generations of times
are likely to be more difficult.

(ref:difficulty-score-by-generation) Accumulated difficulty scores by each generation.

```{r difficulty-score-by-generation, fig.cap="(ref:difficulty-score-by-generation)"}
difficulty_score_by_generation_plot
```

### Learning times

Problem solving with inheritance is divided into two stages: a learning
stage, and a playing stage. Problem solvers begin in the learning stage,
which is the time spent recreating the items whose recipe for construction
had been inherited from a previous generation. On average, diachronic problem
solvers after the first generation spent `r exp1$mean_learning_time_min` minutes
of a 25 minute session (`r exp1$proportion_learning_time`%) in the learning
stage (Fig. \@ref(fig:learning-times)A).

The length of the learning stage depended on the number of items that were
inherited. On average diachronic problem solvers inherited
`r exp1$mean_inheritance_size` items (SD=`r exp1$sd_inheritance_size`). The
length of the learning stage scaled linearly with the size of the inheritance,
`r report_lm_mod(learning_rates_mod, "InheritanceSize")` (Fig. \@ref(fig:learning-times)B),
but there were some exceptions; some participants took disproportionately
long to recreate the items discovered by their ancestor.

```{r learning-times, fig.height=3}
grid.arrange(
  learning_times_plot + ggtitle("A"),
  learning_rates_plot + ggtitle("B"),
  nrow = 1
)
```

Some participants discovered new items that had not been discoverd by their
ancestor while they were still in the learning stage. That is, they discovered
new items while there were still items discovered by their ancestor that had not
been created yet. This suggests that diachronic problem solving is not the
result of first inheriting and then innovating, but that innovation can occur
at any point during the learning stage.

### Size of inheritance

How does the size of the inheritance impact the number
of new innovations that were created?

```{r size-of-inheritance, fig.width=8, fig.height=3}
grid.arrange(
  innovations_created_and_inherited_plot,
  unique_innovations_plot,
  playing_time_plot,
  nrow = 1
)
```

Rather than looking just at the number of new innovations,
we really want to investigate the rate of new innovations
in the playing stage.

```{r diachronic-player-trajectories-plot, fig.width=6}
diachronic_player_trajectories_plot
```

(ref:guesses-per-item-by-inheritance) Guesses per innovation by inheritance condition.

```{r guesses-per-item-by-inheritance, fig.cap="(ref:guesses-per-item-by-inheritance)"}
guesses_per_item_by_inheritance_plot
```

### Guessing strategy

Each guess can be classified in one of four ways (Table \@ref(tab:types-of-guesses)). Guesses that had never been made by the participant before were unique item guesses if they created a new item, or simply a unique guess if the guess did not create any item. Guesses that had been made before either could repeat a previously created item, or they could be redundant guesses. We refer to the distribution of guesses
in these four categories as the guessing strategy.

(ref:types-of-guesses) Four kinds of guesses. Redundant guesses were incorrect guesses that had already been made. Repeat item guesses recreated a previously discovered item. Unique guesses had not been tried before, but did not result in a new item. Unique item guesses were unique guesses that resulted in the creation of a new item.

```{r types-of-guesses, results="asis"}
recode_guess_type() %>%
  select(GuessTypeLabel, UniqueGuess, CreatedItem, UniqueResult) %>%
  kable(caption = "(ref:types-of-guesses)")
```

To investigate the impact of inheritance on problem solving ability, we compared the
guessing strategy of problem solvers without inheritance (generation 1 problem solvers)
to the guessing strategy of problem solvers with inheritance. We found that
diachronic inheritance resulted in fewer redundant guesses than problem solving
without inheritance, `r report_lm_mod(redundant_guesses_mod, "Diachronic_v_NoInheritance")`.

Problem solving with inheritance did not result in an increase in the proportion of
unique guesses, `r report_lm_mod(redundant_guesses_mod, "Diachronic_v_NoInheritance")`.

```{r guess-types-prop, fig.width=6}
guess_types_prop_plot
```

## Discussion

That a larger inheritance---more solutions inherited from a previous
generation---results in more time saved not having to redundantly solve the same
problems is a tautology. But does the amount of time saved scale linearly with
the amount of time invested in creating the inheritance? To answer this
question, the total amount of labor hours must be taken into account by
including the first generation problem solvers in the analysis.

# Experiment 2

# Experiment 3

# Experiment 4

# Discussion

# References
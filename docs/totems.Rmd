---
title: "The impact of inheritance on problem solving ability"
author: "Pierce Edmiston, Max Derex, & Gary Lupyan"
abstract: |
  Human accumulate cultural products including tools and other technology like
  no other species of animal. Cultural accumulation is enabled by the ability to
  inherit tools and other solutions to problems that were first created by other
  people. A result of cultural accumulation is that problem solvers rarely have
  to start from scratch when solving even new problems, as demonstrated by the
  widespread prevalence of reuse in the history of human technology. But what is
  the impact of inheritance---starting off a problem solving task with a partial
  solution that was created by a prior generation---on problem solving ability?
  Does inheriting from a previous generation simply save time in future problem
  solving, or does it affect the rate at which new problems are solved? To
  answer this question, we compared problem solving with inheritance to problem
  solving without inheritance.
csl: "theme/apa.csl"
bibliography: "refs/diachronic-collaboration.bib"
output:
  bookdown::html_document2:
    toc: true
    toc_depth: 2
    toc_float: true
    css: theme/style.css
    keep_md: true
---
```{r config, include=FALSE}
library(knitr)
library(crotchet)

opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE,
  results = "hide",
  fig.width = 4,
  fig.height = 4,
  dpi = 144,
  cache = TRUE
)

sapply(list.files("R", "*.R", full.names = TRUE), read_chunk)
```

```{r setup, include=TRUE, cache=FALSE}
```

# Introduction {-}

```{r intro, include=TRUE}
```

Humans are effective problem solvers. Part of this effectiveness comes from the
ability to reuse and adapt solutions to problems that were first created by
other people. Inventors rarely create inventions with no precursors, and
commonly use and adapt inventions that were first created by other people
[@Basalla:1989wq; @Valverde:2007fs] [cf. @Borner:2004dm]. But what do innovators
and other problem solvers gain from adapting solutions created by others? Do
problem solvers gain a head start on future problem solving, or does inheriting
an existing solution to a problem affect the way in which future problems are
solved?

This research investigates the impact of inheritance on problem solving ability
by studying the problem solving ability of individuals who inherit the solutions
created by a previous generation at the start of a problem solving task. This
type of collaboration, organized around inheritance, will be referred to as
**diachronic collaboration** (Fig. \@ref(fig:team-structures)). To understand
how inheritance impacts problem solving ability, I compare the effectiveness of
diachronic collaboration to two alternative strategies for solving the same
problems in the same amount of labor time but without diachronic inheritance:
**synchronic collaboration**, where team members begin with nothing and
collaborate in parallel, and **isolated individuals**, given the most time for
individual learning (Fig. \@ref(fig:team-structures)). The purpose of this
comparison is to understand the impact of inheritance on problem solving by
comparing problem solving ability when starting with an inherited
solution---defined as diachronic problem solvers after the first generation---to
alternative strategies for solving the same problems without diachronic
inheritance.

(ref:team-structures) Problem solving strategies. Each node is a single problem
solver. Edge lengths represent labor hours spent solving a set of problems. In
diachronic collaboration, first generation problem solvers work on solutions to
problems before passing them on to be inherited by the next generation. The
impact of inheritance on problem solving is measured as the problem solving
ability of diachronic problem solvers after the first generation. Isolated
individuals do not inherit solutions from other players, but are given the most
time for individual learning. In synchronic collaboration, multiple problem
solvers work in parallel, sharing their progress, but synchronic teams do not
benefit from direct diachronic inheritance because all problem solvers start at
the same point.

```{r team-structures, fig.width=1.5, fig.cap="(ref:team-structures)"}
draw_graphviz("team-structures", "totems")
```

The synchronic and isolated strategies serve as control conditions in these
experiments: ways of solving the same set of problems without diachronic
inheritance. Synchronic and isolated problem solvers all begin the problem
solving task at the same starting point. Only diachronic problem solvers after
the first generation inherit solutions from the previous generation to
start.

The three strategies considered here are overlapping in some aspects. The
problem solvers using a synchronic strategy can share or "inherit" solutions
from one another. What distinguishes diachronic and synchronic inheritance is
when the solutions are shared. For diachronic problem solvers, solutions are
inherited once, at the start of the problem solving task. For synchronic
problem solvers, solutions are inherited intermittently, throughout the task.

A third type of inheritance, individual inheritance, is introduced in Experiment
2. Individual inheritance is when one's own problem solving is resumed in
subsequent sessions. Individual inheritance involves inheriting from oneself, as
opposed to inheriting from someone else. The purpose of this research is to
investigate specifically how diachronic inheritance may impact problem solving
ability differently than these alternative ways of solving the same set of
problems.

Computational and experimental models of cultural evolution have traditionally
compared two types of learning: individual learning and social learning. In
explaining why humans are able to accumulate cultural products and technological
improvements, the evidence points to a suite of social learning strategies that
humans possess that make us capable of propagating cultural innovations in a
population. Even discoveries that happen by accident can survive to be
replicated throughout a population.

However, most previous approaches have not directly measured the cost savings
from social learning relative to individual learning in terms of **labor hours**,
opting instead to control for **calendar hours**. For example, a group of 5 social
learners who each spend an hour on a task is measured against the success of an
individual learner given the same amount of calendar time: a single hour. Controlling
for labor time would mean the problem solving ability of a group of 5 social
learners each working for one hour should be compared to an isolated individual
given 5 hours.

In order to fully understand the impact of inheritance on problem solving
ability, it is necessary to account for both the cost of creating the
inheritance as well as the consequences of inheritance on future problem
solving. In this study the cost and consequence of inheritance is controlled by
allotting a fixed number of labor hours to diachronic teams. The other
strategies investigated in this research are compared given the same number of
labor hours. Labor hours can be contrasted by two other measures of time that
are not controlled in these experiments: calendar hours and individual learning
hours (Fig. \@ref(fig:types-of-time)).

(ref:types-of-time) Types of time. **Left.** Key for problem solving strategies.
**Middle.** Relationship between calendar hours and labor hours. Synchronic
collaboration consumes a fixed amount of labor time more rapidly (per calendar
hour) than either the diachronic or isolated strategies. **Right.** Amount of
individual learning time in each strategy. An isolated strategy maximizes the
amount of time for individual learning.

```{r types-of-time, fig.width=8, fig.height=3, fig.cap="(ref:types-of-time)"}
grid.arrange(
  read_graphviz("team-structures", "totems"),
  gg_time,
  gg_person,
  nrow = 1,
  widths = c(0.2, 0.4, 0.4)
)
```

# Methods {-}

```{r methods, include=FALSE}
```

Participants were recruited to engage in a problem solving task requiring them
to solve a series of smaller problems in service of meeting a larger problem
solving goal. Participants were randomly assigned to either the diachronic
condition (the treatment condition) or one of the control conditions: isolated
or synchronic. Participants in the diachronic condition either participated as a
first generation problem solver, or began the problem solving task with the
solutions discovered by a previous generation. Participants in the synchronic
condition collaborated in parallel via separate computers. Once a solution was
discovered by a synchronic participant, it became available for all members of
the synchronic team. Participants in the isolated condition participated in a
single 50 minute session, or alternately returned for four 25 minute sessions
spaced least one day apart. When isolated participants returned for later
sessions, they inherited the tools they had discovered in the previous session.

The data generated using these methods are reported in four experiments.
Experiment 1 investigates the result of accumulated inheritance over four
generations of problem solving. The analyses explore the differences between
first generation problem solvers and problem solvers who benefit from
inheritance, defined as diachronic problem solvers after the first generation.
In Experiment 2, we compare the simplest form of diachronic inheritance, a
two-person diachronic team, to a two-person synchronic strategy and an isolated
individual given 50 minutes. In Experiment 3, inheriting from someone else
as in diachronic teams is compared to inheriting from oneself: isolated
participants returning for multiple sessions. Experiment 4 compares the three
main strategies given 100 minutes, including a four-person synchronic strategy.

(ref:team-structures-all) All experimental conditions. The **Diachronic**
condition is the treatment condition: problem solving with inheritance. First
generation diachronic participants began without any previous solutions and
worked on the problem solving task for 25 minutes. Diachronic participants
assigned to generation 2-4 inherited the solutions discovered by the previous
generation at the start of the problem solving task. The two control conditions
were Isolated and Synchronic. **Isolated** participants either completed a
single 50 minute session, or returned for 4 subsequent 25 minute sessions. Upon
returning, these participants "inherited" the solutions they had created in the
previous session. **Synchronic** participants completed the problem solving task
in groups of 2 or 4 individuals, each participating for 25 minutes. Synchronic
participants collaborated in parallel, sharing solutions with all team members
as they were discovered.

```{r team-structures-all, fig.cap="(ref:team-structures-all)"}
draw_graphviz("team-structures-all", "totems")
```

## Materials and Procedure {-}

### The Totems game

Participants played a computer game, first reported in @Derex:2015cbb, requiring
players to iteratively solve problems related to creating new tools out of
existing items for the purposes of building "a sacred totem to appease the gods."
To build a totem, participants first needed to construct an axe out of three
independently discovered items: a refined stick used as a handle, a sharpened
rock for the blade, and string wound from bark fibers for binding (Fig.
\@ref(fig:landscape-sample)). In the game, more advanced tools produce larger
and more intricate totems, resulting in higher performance scores.

(ref:landscape-sample) A sample of the solution landscape. The top row of 6
items are the initial resources available to problem solvers at the start of the
session. Resources must be combined to build the first generation of
innovations, including a refined rock, a club derived from an antler, and a
small branch of a tree. The first 6 generations of possible innovations are
shown. The axe is required to construct the first totem pole.

```{r landscape-sample, fig.cap="(ref:landscape-sample)"}
# draw_graphviz_with_images("landscape-sample", "totems")
draw_image("landscape-sample.gv", "totems")
```

### Guesses

Participants solved problems by trial-and-error guessing of different
combinations of items they believed would yield new tools. To generate new
guesses, participants dragged items into a workshop panel (Fig.
\@ref(fig:interface)).

Of all the valid combinations of items that could be made, only a small
percentage successfully yielded new items. The 6 initial resources can be
combined with between 1 and 4 other items with replacement for a total of
`r count_unique_guesses_with_replacement(6)` unique guesses, only three of which
yield any new tools: a branch can be broken off a tree, an antler refined into
a club, and two rocks can be combined to yield a shaped stone. As the number
of items available to each problem solver increased, so did the combinatorial
complexity of the problem space. Thus, problems became more difficult
over time.

### Stock

If a guess yielded an item, it could be stored in a stock panel. A maximum of 12
items could be stored in the stock panel at any given time. Items could be
discarded if space was needed in the stock panel for new items, or if an item
was not needed for any reason.

### Recipes

Once an item was discovered, the recipe for its creation was recorded in the
history panel. Participants could review their item history and see the recipes
for their previous innovations, even items they had discarded.

In addition to an individual history, the history pane also had other tabs,
depending on which strategy each participant was assigned. Diachronic
participants after the first generation began with a tab that could be selected
to show all item recipes discovered by the previous generation. This was the way
in which solutions to previous problems were shared with future generations.
Isolated participants, if returning for multiple sessions, had a tab with the
solutions they had come up with during their previous session. Synchronic
participants had tabs for other synchronic problem solvers on their team.
The tab displayed the current score of each player, so synchronic were notified
that a discovery had been made by seeing a change in their teammates' score.

(ref:interface) The Totems gameplay interface. Participants generated guesses
by dragging items into the Workshop and selecting the Try button. If the guess
created an item, it could be dragged into the Stock panel, and used again. Once
segments of a totem were made through cutting, carving, and painting, they could be
dragged into the Totem panel for scoring.

```{r interface, fig.cap="(ref:interface)"}
draw_image("gameplay", "totems")
```

### Post experiment survey

After the experiment was completed, participants completed a brief post
experiment survey assessing their understanding of the task, their experience
with games like the Totems game, and whether they used any particular strategy
for guessing.

## Participants {-}

Participants (N=`n_recruited`) were students at the University of
Wisconsin-Madison who completed the experiment in exchange for course credit.
Students received credit for each completed session based on the duration of the
session, 25 minutes or 50 minutes. Participants in the Isolated, multi-session
experiment who completed all four sessions were awarded additional credit.

Participants were recruited until there were at least 40 teams in each strategy.
Most strategies, other than four-person synchronic teams, ended up receiving
more than 40 teams. The reason for this is that participants were scheduled in
groups of 4 participants at a time, and frequently one or more participants
would fail to show up for their extra credit opportunity. In these cases, the
remaining participants were run as a combination of diachronic and
two-person synchronic participants.

Data from individual participants were excluded from the final analyses (N=`n_excluded`)
for the following reasons. Most of these (N=`n_errors`) were excluded because
they experienced errors in the computer game. Others (N=`n_noncomplaint`) were
noncomplaint, giving up on the problem solving task (N=`n_gave_up`).

```{r counts-table, results="asis"}
kable(ConditionCounts, caption = "Total participant and team recruitment.")
```

# Experiment 1 {-}

```{r exp1, include=FALSE}
```

In the first experiment, we measure the impact of inheritance on problem solving
over four generations of diachronic problem solvers (Fig.
\@ref(fig:team-structures-exp1)). Our analyses answer the following questions
about the impact of diachronic inheritance on problem solving. First, we ask
whether and by how much future generations of problem solvers are able to exceed
the solutions obtained by their ancestors. Second, we ask how diachronic problem
solvers are affected by the size of their inheritance. Does the impact of
inheritance on future problem solving depend on the size of the inheritance? Finally,
we ask whether diachronic inheritance affects the type of guesses generated
by future generations of problem solvers. To answer this question, we compare
the rates of redundant to unique guesses among first generation problem solvers
to future generations of problem solvers.

```{r team-structures-exp1}
draw_graphviz("team-structures-exp1", "totems")
```

## Results {-}

### Innovations by generation {-}

Diachronic problem solvers were consistently able to exceed the number of
innovations discovered by their ancestors (Fig. \@ref(innovations-by-generation)).
The benefit of inheritance decreased over generations, such that later
generations of problem solvers benefitted less from inheritance than previous
generations. Part of the reason for this is independent of inheritance and may
deal with the combinatorial complexity that results from generating guesses from
a larger inventory of items.

(ref:innovations-by-generation) Diachronic performance by generation.

```{r innovations-by-generation, fig.cap="(ref:innovations-by-generation)"}
innovations_by_generation_plot
```

### Guesses per innovation {-}

Problem solving with inheritance is divided into two stages: a learning
stage, and a playing stage. Problem solvers begin in the learning stage.
The learning stage is defined as the time spent recreating the items whose
recipe for construction had been inherited from a previous generation.
On average, diachronic problem solvers after the first generation
spent `r exp1$mean_learning_time_min` minutes of a 25 minute session
(`r exp1$proportion_learning_time`%) in the learning stage.

The length of the learning stage depended on the number of items that were
inherited. On average diachronic problem solvers inherited
`r exp1$mean_inheritance_size` items (SD=`r exp1$sd_inheritance_size`). The
length of the learning stage scaled linearly with the size of the inheritance,
`r report_lm_mod(learning_rates_mod, "InheritanceSize")`,
but there were some exceptions; some participants took disproportionately
long to recreate the items discovered by their ancestor.

Some participants discovered new items that had not been discoverd by their
ancestor while they were still in the learning stage. That is, they discovered
new items while there were still items discovered by their ancestor that had not
been created yet. This suggests that diachronic problem solving is not the
result of first inheriting and then innovating, but that innovation can occur
at any point during the learning stage.

```{r diachronic-player-trajectories-plot, fig.width=6}
diachronic_player_trajectories_plot
```

Once all inherited items have been created, problem solvers
begin the playing stage, where they are tasked with discovering
new items not discovered by their ancestor.

(ref:guesses-per-item-by-inheritance) Guesses per innovation by inheritance condition.

```{r guesses-per-item-by-inheritance, fig.cap="(ref:guesses-per-item-by-inheritance)"}
guesses_per_item_by_inheritance_plot
```

### Guessing strategy

Each guess can be classified in one of four ways (Table \@ref(tab:types-of-guesses)). Guesses that had never been made by the participant before were unique item guesses if they created a new item, or simply a unique guess if the guess did not create any item. Guesses that had been made before either could repeat a previously created item, or they could be redundant guesses. We refer to the distribution of guesses
in these four categories as the guessing strategy.

(ref:types-of-guesses) Four kinds of guesses. Redundant guesses were incorrect guesses that had already been made. Repeat item guesses recreated a previously discovered item. Unique guesses had not been tried before, but did not result in a new item. Unique item guesses were unique guesses that resulted in the creation of a new item.

```{r types-of-guesses, results="asis"}
recode_guess_type() %>%
  select(GuessTypeLabel, UniqueGuess, CreatedItem, UniqueResult) %>%
  kable(caption = "(ref:types-of-guesses)")
```

To investigate the impact of inheritance on problem solving ability, we compared the
guessing strategy of problem solvers without inheritance (generation 1 problem solvers)
to the guessing strategy of problem solvers with inheritance. We found that
diachronic inheritance resulted in fewer redundant guesses than problem solving
without inheritance, `r report_lm_mod(redundant_guesses_mod, "Diachronic_v_NoInheritance")`.

Problem solving with inheritance did not result in an increase in the proportion of
unique guesses, `r report_lm_mod(redundant_guesses_mod, "Diachronic_v_NoInheritance")`.

```{r guess-types-prop, fig.width=6}
guess_types_prop_plot
```

# Experiment 2 {-}

```{r exp2, include=FALSE}
```

In the second experiment we compared the effectiveness of the simplest form
of inheritance involving a two-person diachronic team to alternative strategies
for allocating 50 labor minutes (Fig. \@ref(fig:team-structures-exp1)).
Our analyses focus on the overall achievements of second generation diachronic
participants compared to the alternatives, as well as the differences in
problem solving strategy induced via diachronic inheritance. Specifically,
we tested the hypothesis that diachronic collaboration resulted in a more
efficient use of labor hours compared to alternative forms of problem solving.

(ref:team-structures-exp1) Problem solving strategies compared in Experiment 1. Each strategy
was allotted 50 labor minutes. The treatment condition was the diachronic strategy, and the
impact of inheritance on problem solving ability is measured as the problem solving ability
of the second generation diachronic participant who begins the problem solving task with the
solutions discovered by the previous generation. The other conditions are control conditions,
representing alternative ways of solving the same set of problems without diachronic inheritance.

```{r team-structures-exp1, fig.cap="(ref:team-structures-exp1)"}
draw_graphviz("team-structures-exp1", "totems")
```

## Methods {-}

Participants completed the Totems game in either a 25-minute session or a 50-minute session.
All participants recruited for a 50-minute session were assigned to the isolated
condition. Participants recruited for a 25-minute session were randomly assigned either
to the diachronic or synchronic conditions. Participants assigned to the diachronic
condition were assigned to new or existing diachronic team. If they were assigned
to a new team, they became the first generation participant. If they were assigned
to an existing team, they inherited the items discovered by the
previous (first) generation of that team.

### Participants {-}

The total number of participants and teams included in this analysis are
presented in Table \@ref(tab:counts-table-50).

(ref:counts-table-50) Participants used in the 50 labor minute experiment.

```{r counts-table-50, results="asis", fig.pos="h"}
kable(ConditionCounts50, caption = "(ref:counts-table-50)")
```

## Results {-}

### Number of innovations {-}

The impact of inheritance on the total number of discoveries made via
different strategies for problem solving is shown in Fig. \@ref(fig:num-
innovations-50min-fig). Second generation diachronic problem solvers
reliably exceeded the discoveries made by their first generation
ancestors, `r report_lmer_mod(num_innovations_50min_mod, "DG2_v_DG1")`.
The advantage of diachronic problem solving over an isolated individual
given 50 minutes was smaller and not statistically significant
`r report_lmer_mod(num_innovations_50min_mod, "DG2_v_I50")`. A diachronic
strategy given 50 minutes performed worse than a two-person synchronic strategy,
but this difference was small as well and not statistically significant,
`r report_lmer_mod(num_innovations_50min_mod, "DG2_v_S2")`.

(ref:num-innovations-50min-fig) Number of innovations discovered by each
strategy. **Top left.** Key showing experimental conditions. **Top right.** Final number
of innovations. Each point represents the number of innovations created by a
single player in a single session. Bars and error lines show point estimates
from the linear model. **Bottom.** Innovation rate by strategy. Innovation rates
are given in terms of labor time, which differs from calendar time and time
for individual learning (see Fig. \@ref(fig:types-of-time)).

```{r num-innovations-50min-fig, fig.height=6, fig.width=8, fig.cap="(ref:num-innovations-50min-fig)"}
grid.arrange(
  arrangeGrob(
    read_graphviz("team-structures-exp1", "totems"),
    num_innovations_50min_plot,
    nrow = 1,
    widths = c(0.4, 0.6)
  ),
  innovation_rate_50min_plot +
    theme(legend.position = c(0.11, 0.75))
)
```

```{r num-innovations-50min-mod, results="asis"}
num_innovations_50min_mod <- lmer(
  NumInnovations ~ DG2_v_DG1 + DG2_v_I50 + DG2_v_S2 + (1|TeamID),
  data = PlayerPerformance50min
)
tidy(num_innovations_50min_mod, effects = "fixed") %>%
  kable(caption = "Model results estimating the final number of innovations discovered by each participant in each strategy. Strategies were Diachronic Generation 1 (DG1), Diachronic Generation 2 (DG2), Isolated 50min (I50), and 2-person Synchronic (S2). Strategy was coded with treatment contrasts using DG2 participants as the comparison group. For example, the model parameter DG2 v DG1 indicates the difference in final number of innovations between second and first generation diachronic players.")
```

Participants in both strategies involving inheritance from
other people (diachronic and synchronic) outperformed isolated
individuals given the same total amount of labor time,
`r report_lmer_mod(num_innovations_50min_teamwork_mod, "DSvI")`.
In this model, fit with Helmert contrasts, there was no residual
difference between diachronic and synchronic strategies,
`r report_lmer_mod(num_innovations_50min_teamwork_mod, "DvS")`.

```{r num-innovations-50min-teamwork-mod, results="asis"}
num_innovations_50min_teamwork_mod <- lmer(
  NumInnovations ~ DSvI + DvS + (1|TeamID),
  data = filter(PlayerPerformance50min, SessionType != "DG1")
)
tidy(num_innovations_50min_teamwork_mod, effects = "fixed") %>%
  kable(caption = "Model results estimating the effectiveness of teamwork (Diachronic + Synchronic) versus an Isolated strategy. Strategy was coded with Helmert contrasts. The parameter DSvI compares the final number of innovations discovered by second generation Diachronic participants and Synchronic participants to the number of innovations discovered by isolated individuals in a single 50 minute session. The parameter DvS compares the residual difference between Diachronic and Synchronic participants.")
```

(ref:innovation-rate-50min-types-of-time-fig) Comparing innovation rate by different
measures of time.

```{r innovation-rate-50min-types-of-time-fig, fig.width=8, fig.height=8, fig.cap="(ref:innovation-rate-50min-types-of-time-fig)"}
grid.arrange(
  arrangeGrob(
    read_graphviz("team-structures", "totems"),
    gg_time,
    gg_person,
    nrow = 1,
    widths = c(0.2, 0.4, 0.4)
  ),
  innovation_rate_50min_plot +
    aes(CalendarTime) +
    t_$scale_x_calendar_time +
    theme(legend.position = c(0.12, 0.75)),
  innovation_rate_50min_plot +
    aes(PlayerTime) +
    t_$scale_x_player_time +
    theme(legend.position = "none"),
  innovation_rate_50min_plot +
    theme(legend.position = "none"),
  ncol = 1
)
```

### Guesses per innovation {-}

We next report whether diachronic inheritance resulted in a unique problem
solving strategy relative to the other ways of solving the same set of problems.
To answer this question, we first tallied the number of guesses that each item
required before being discovered. This was done by counting the number of
guesses that were made in which the prerequisite items for a particular
innovation had already been discovered, but the correct guess for the novel
target item was not made. The tallies take into account for which items were
"adjacent" to each individual's innovation record. For example, the count of the
number of guesses it took for a participant to discover their first totem only
begins after the axe had been discovered, which is required in the recipe for
constructing the totem.

Counting guesses in this way revealed that diachronic participants benefiting
from inheritance averaged fewer guesses per item than strategies without any
diachronic inheritance,
`r report_lmer_mod(guesses_per_item_by_inheritance_mod, "Diachronic_v_NoInheritance")`.

```{r guesses-per-item-by-inheritance-50min-mod, results="asis"}
guesses_per_item_by_inheritance_mod <- lmer(
  TotalGuesses ~ Diachronic_v_NoInheritance +
    (Diachronic_v_NoInheritance|Adjacent) +
    (1|TeamID),
  data = filter(CostPerItem50min, Discovered))
tidy(guesses_per_item_by_inheritance_mod, effects = "fixed") %>%
  kable(caption = "Model results estimating number of guesses for each item based on inheritance condition. The model compares the number of guesses made for each item by second generation diachronic participants to the conditions without any inheritance.")
```

The reason inheritance results in fewer guesses per item is because they start
off with the recipes that had already been discovered. They started with a
partial answer key. A second generation diachronic participants session can thus
be divided into two parts: time spent learning from the previous generation, and
time spent generating novel innovations.

```{r guesses-per-item-by-inheritance-50min-playing-mod, results="asis"}
guesses_per_item_by_inheritance_playing_mod <- lmer(
  TotalGuesses ~ Diachronic_v_NoInheritance +
    (Diachronic_v_NoInheritance|Adjacent) +
    (1|TeamID),
  data = filter(CostPerItem50minPlaying, Discovered))
tidy(guesses_per_item_by_inheritance_playing_mod, effects = "fixed") %>%
  kable(caption = "Model results estimating number of guesses for each item based on inheritance condition.")
```

(ref:guesses-per-item-by-inheritance-50min-fig) The impact of inheritance on the
average number of guesses for each discovery. **Top**. Total number of guesses
per item. Each line shows the average number of guesses made for a particular
item when being guessed in either a condition without inheritance, or a
condition with diachronic inheritance. On the left is the number of guesses made
for all items. On the right is the number of guesses made for new items.
Diachronic inheritance reduced the average number of guesses made for each
discovery, but only for discoveries that had already been made by the previous
generation. For new items, diachronic inheritance had no impact on future
problem solving. **Bottom**. Example trajectories for second generation
diachronic players, showing the time taken to recreate all previous items,
followed by the time taken to create new items.

```{r guesses-per-item-by-inheritance-50min-fig, fig.width=8, fig.height=6, fig.cap="(ref:guesses-per-item-by-inheritance-50min-fig)"}
grid.arrange(guesses_per_item_by_inheritance_plot + ggtitle("All items"),
              guesses_per_new_item_by_inheritance_plot + ggtitle("New items"),
              nrow = 1)
```

### Guess types {-}

Next we report the impact of inheritance on guessing strategy, as defined
as the proportion of guesses made by guess type. Each guess could be
classified as one of four different types of guesses. Redundant guesses
were incorrect guesses that had already been made once before. These are
the most inefficient type of guesses. Repeat item guesses recreated a previously
discovered item. Unique guesses had not been tried before, but they were
ultimately incorrect, and did not result in the creation of a new item.
Finally, unique item guesses were guesses that yielded a new item.

To investigate the impact of inheritance on guessing strategy, we
measured whether diachronic problem solvers generated different proportions
of guesses relative to the other strategies. We found that diachronic
problem solvers generated a lower proportion of redundant guesses than
both their first generation ancestors,
`r report_lm_mod(prop_redundant_guesses_mod, "DG2_v_DG1")`,
as well as isolated individuals given 50 minutes,
`r report_lm_mod(prop_redundant_guesses_mod, "DG2_v_I50")`.
Diachronic problem solvers also had a higher proportion of unique guesses
than isolated individuals, `r report_lm_mod(prop_unique_guesses_mod, "DG2_v_I50")`,
but not first generation diachronic problem solvers,
`r report_lm_mod(prop_unique_guesses_mod, "DG2_v_DG1")`.

(ref:prop-guess-types-50min-fig) Proportion of guesses made by problem solvers
in each strategy.

```{r prop-guess-types-50min-fig, fig.width=6, fig.cap="(ref:prop-guess-types-50min-fig)"}
prop_guess_types_50min_plot
```

# Experiment 3 {-}

```{r exp3, include=FALSE}
```

## Methods {-}

```{r team-structures-exp2, fig.width=3}
draw_graphviz("team-structures-exp2", "totems")
```

### Participants {-}

## Results {-}

### Number of innovations following inheritance {-}

```{r}
num_innovations_by_generation_100_plot
```

```{r}
num_innovations_by_generation_100_plot_grouped
```

```{r}
num_unique_innovations_100_plot
```

### Cost of first innovation {-}

```{r}
first_discovery_plot
```

# Experiment 4 {-}

```{r exp4, include=FALSE}
```

```{r team-structures-exp3}
draw_graphviz("team-structures-exp3", "totems")
```

## Methods {-}

### Participants {-}

```{r counts-table-100, results="asis"}
kable(ConditionCounts100)
```

## Results {-}

```{r, fig.width=6}
num_innovations_100min_plot
```

# Discussion {-}

# References {-}
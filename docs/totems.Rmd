---
title: "What is the impact of inheritance on problem solving ability?"
author: "Pierce Edmiston"
csl: "apa.csl"
css: "style.css"
bibliography: "diachronic-collaboration.bib"
output:
  html_document:
    theme: flatly
---

```{r config, include = FALSE}
library(knitr)
library(printr)
library(magrittr)

opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE,
  results = "hide",
  fig.path = "figs/",
  fig.width = 6,
  fig.height = 6,
  cache = TRUE,
  cache.path = ".cache/"
)

list.files("R", "*.R", full.names = TRUE) %>% sapply(read_chunk)
```

```{r setup}
```

What is the impact of inheritance on the problem solving ability of individuals? Does inheriting an existing solution to a problem simply give a head start on solving it, or does it actually make for more effective problem solving? To answer this question I consider a simple form of inheritance where one person works on a solution to a problem and then passes it on to another person to continue. Because these two individuals are collaborating over time, I refer to them as **diachronic teams**. To understand the impact of inheritance on problem solving, I compare the problem solving abilities of diachronic teams to two alternative ways of allocating the same number of labor hours: **isolated individuals** working for the same total amount of time, and **synchronic teams** made of two individuals collaborating at the same time (Fig. 1).

```{r types-of-time, fig.width=8, fig.align="center", fig.cap="**A.** Three strategies for allocating the same number of labor hours. Panels B and C describe the ways the strategies differ along different dimensions of time. **B.** By controlling for labor hours, diachronic and synchronic teams differ in calendar hours. Diachronic teams spend labor hours at the same rate as isolated individuals. **C.** Isolated individuals have the most time to learn."}
```

## Problem solving ability and problem solutions

In this research I measure problem solving ability as efficiency in completing a problem in a specific amount of time. In other research, problem solving is described as the set of cognitive abilities that enable the generation of problem solutions. Here I'm interested less in whether solutions can be generated and more in how efficiently those solutions are reached. The goal of this research is to understand the impact of inheritance on problem solving ability.

\begin{equation}
problem\ solution = ability \cdot time\ +\\\times inheritance\\
\end{equation}

# Methods

## Participants

Participants are recruited until the final sample comprises 40 teams in each of the three strategy conditions for a total of 200 participants.

## Materials

Participants are tasked with a tool-building competition presented in a digital environment [@Derex:2015cbb]. Individuals combine resources and build ever more complicated tools in order to build "sacred totems to appease the gods". Individuals achieve high scores by traversing the innovation landscape and developing more and more elaborate ways of cutting, carving, and decorating their totems. A sample of the problem space is presented in Fig. 2.

```{r, cache = FALSE, include = FALSE}
crotchet::read_graphviz_chunk("landscape-sample", package = "totems")
```

```{r landscape-sample, engine = "dot", fig.width = 4, cache = FALSE}
```

## Procedure

```{r}
grid.draw(png::readPNG("../docs/irb/methods/screenshots/gameplay.png") %>% rasterGrob())
```

# Results

```{r data, echo = 1:4}
```

## Performance

```{r performance, fig.width=8}
```

```{r performance-mods, results = "asis"}
list(Score = tidy(score_mod),
     InventorySize = tidy(inventory_mod),
     DifficultyScore = tidy(difficulty_mod)) %>%
  bind_rows(.id = "model") %>%
  filter(term != "(Intercept)")
```

## Attempts

```{r attempts-plot, fig.width=8}
attempts_plot <- ggplot(filter(player_ratchets, Measure == "Score")) +
  aes(StrategyLabel, Attempts) +
  geom_point(aes(color = StrategyLabel),
             position = position_jitter(width = 0.3)) +
  geom_bar(aes(fill = StrategyLabel),
           stat = "summary", fun.y = "mean", alpha = 0.6) +
  facet_wrap("AttemptMeasureLabel") +
  totems_theme["scale_x_strategy"] +
  totems_theme["scale_color_strategy"] +
  totems_theme["scale_fill_strategy"] +
  totems_theme["base_theme"] +
  theme(
    legend.position = "none",
    panel.grid.major.x = element_blank()
  )
attempts_plot
```

```{r ratchets-plot, fig.width=8, fig.height=12}
ggplot(player_ratchets) +
  aes(Attempts, Value, color = StrategyLabel) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) +
  ylab("") +
  totems_theme["scale_color_strategy"] +
  totems_theme["base_theme"] +
  theme(
    legend.position = "none",
    strip.placement = "outside"
  ) +
  facet_grid(MeasureLabel ~ AttemptMeasureLabel, scales = "free_y", switch = "y")
```

## Timeline

```{r}
totems_workshops %<>%
  mutate(
    TeamTime = milliseconds(totems_workshops$TeamTime),
    ID_Group_Time = ifelse(Strategy == "Diachronic", paste(ID_Group, Generation, sep = "-"), ID_Group),
    Strategy_Group_Time = ifelse(Strategy == "Diachronic", paste0(Strategy, Generation), Strategy)
  )

ggplot(totems_workshops) +
  aes(TeamTime, InventorySize, group = ID_Group_Time, color = StrategyLabel) +
  geom_line(alpha = 0.4) +
  geom_smooth(aes(group = Strategy_Group_Time), method = "loess", se = FALSE) +
  scale_x_time("Team time", breaks = minutes(seq(0, 50, by = 25))) +
  totems_theme["scale_color_strategy"] +
  totems_theme["base_theme"] +
  theme(legend.position = "top")
```

# Discussion

# References

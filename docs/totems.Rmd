---
title: "The impact of inheritance on problem solving ability"
author: "Pierce Edmiston"
abstract: |
  Human cultures are able to accumulate products of culture including tools and
  other technology like no other animal. The cognitive ability that enables
  cultural accumulation is the ability to inherit innovations, such as an
  improvement in some tool, from previous generations. A result of
  accumulated inheritance is that problem solvers rarely have to start from
  scratch when solving even new problems, as demonstrated by the widepsread
  prevalence of reuse in the evolution of human technology. But what is the
  impact of inheritance---starting with a solution that was created by someone
  else---on problem solving ability? Does inheriting an existing solution to a
  problem only save time in future problem solving, or does it actually
  change the way problems are solved?  The experiments reported here measure
  the impact of inheritance on problem solving ability. In the inheritance
  condition, one person works on a solution to a problem before passing it on
  to be inherited by another person to continue. Because the people this
  exchange are working together, I refer to them as diachronic teams. The
  effectiveness of a diachronic strategy organized around inheritance is
  compared to alternative strategies for allocating the same number of labor
  hours: synchronic teams comprising individuals working in parallel, and
  isolated individuals working for the same total number of labor hours. The
  purpose of this comparison is to understand the conditions under which
  inheritance is most helpful for problem solving. Two hypothesis are tested:
  first, that inheritance will free future generations of problem solvers from
  being fixated on previous and incorrect learning experiences; and second,
  that inheriting solutions from problem solvers with diverse skill sets will
  impact future problem solving more than inheriting solutions from homogenous
  problem solvers. 
csl: "theme/apa.csl"
bibliography: "refs/diachronic-collaboration.bib"
output:
  html_document:
    theme: flatly
    css: theme/style.css
    toc: true
    toc_depth: 2
    toc_float: true
---
```{r config, include = FALSE}
library(knitr)
library(printr)
library(magrittr)
library(crotchet)

opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE,
  results = "hide",
  fig.width = 4,
  fig.height = 4,
  cache = TRUE
)

list.files("R", "*.R", full.names = TRUE) %>% sapply(read_chunk)
read_graphviz_chunk("team-structures", "totems")
read_graphviz_chunk("diachronic-collaboration", "totems")
```

```{r setup, cache = FALSE}
```

# Introduction

On November 1, 2015, the English Wikipedia published its 5 millionth article.
The article, on a shrub native to eastern Australia, was only 9 words long.
Since then, the article has been edited 419 times by 86 different authors, and
now includes 8 different sections on the taxonomy, habitat, and ecology of this
Australian plant.

The collaborative effort of writing a Wikipedia article exhibits a type of
teamwork that is foundational to cumulative cultural evolution, and may be
unique to our species. Humans are particularly adept at using, changing, and,
in some cases, improving cultural products that were first created by other
people. The ability to inherit and improve a tool or some other solution to a
problem is necessary in order to observe the ratcheting of technological
complexity in a culture [@Tomasello:1993vh]. I refer to the type of
collaboration that enables ratcheting as **diachronic collaboration** (Fig. 1).
In diachronic collaboration, the products of labor, such as a tool to solve
some problem, are shared with or inherited by future generations of problem
solvers. The purpose of this research is to understand why diachronic
collaboration may be crucial for cumulative cultural evolution by assessing its
effectiveness as a problem solving strategy.

```{r diachronic-collaboration, engine="dot", fig.width=6, fig.pos="h", out.extra="", fig.cap="In diachronic collaboration, the products of one generation of labor are inherited to be used and improved by the next generation. An example of diachronic collaboration is Wikipedia article writing, where articles are effectively passed from editor to editor in a chain of edits. The ability to engage in diachronic collaboration---to improve something that was created by someone else---is required in order to observe the ratcheting of technological complexity in a culture."}
```

Humans are effective problem solvers. Part of this effectiveness comes from the
ability to reuse and adapt solutions to problems that were first created by
other people. Reuse is common in human history. Inventors rarely create
inventions with no precursors, and commonly use and adapt inventions that were
first created by others [@Basalla:1989wq]. Part of this reuse is the result of
innovation breeding further innovation [@Valverde:2007fs]. But
what do innovators and other problem solvers gain from inheriting solutions
created by previous generations of problem solvers? Does diachronic collaboration simply save time on future problem solving, or does inheriting an existing solution to a problem actually change the way future problems are solved?

The purpose of this research is to identify the conditions under which
inheritance might actually improve one's problem solving ability relative to
the same amount of time spent solving the problem in other ways, without
diachronic inheritance. Specifically, I compare the effectiveness of a
diachronic strategy to two alternative strategies for allocating the same
number of labor hours: synchronic collaboration, where team members begin with
no prior solutions and collaborate in parallel, and isolated individuals, given
the most time for individual learning (Fig. 2). The purpose of this comparison
is to measure the impact of inheritance on problem solving by comparing
problem solving ability when starting with an inherited solution---defined as
diachronic problem solvers after the first generation---to alternative
strategies for solving the same problems without diachronic inheritance.
Discovering whether and under what conditions diachronic collaboration is more
effective than alternative strategies will provide empirical evidence of the
benefits to diachronic collaboration, including the ability to ratchet human
problem solving ability via inheritance.

```{r team-structures, engine="dot", fig.width=2, fig.pos="h", fig.cap="Problem solving strategies. Each node is a person. Edge lengths represent labor hours spent solving a problem. In diachronic collaboration, first generation problem solvers work on a solution to a problem before passing it on to be inherited by the next generation. The impact of inheritance on problem solving is measured as the problem solving ability of diachronic problem solvers after the first generation. Isolated individuals do not inherit solutions from other players, but are given the most time for individual learning. In synchronic collaboration, teams of problem solvers work in parallel, sharing their progress as they go, but synchronic teams do not benefit from direct diachronic inheritance because all problem solvers start without any prior solutions."}
```

In the experiments below I test two main hypotheses regarding the conditions
under which inheritance might be found to improve problem solving ability
relative to the alternative strategies depicted in Fig. 2. The first hypothesis
relates to the kind of problem being solved. Diachronic inheritance is
predicted to be effective in solving problems in which fixation effects are
common. Fixation in problem solving is demonstrated by individuals returning
to, or otherwise being mislead by, previous and incorrect solutions to
problems. **Inheritance is hypothesized to improve future problem solving by
making it unlikely that future generations return to the same incorrect
solutions that may have slowed down previous generations.**

There are two possible mechanisms by which inheritance may overcome the cost of
fixation. The first and most basic is that inheriting a solution that was
difficult for the previous generation to achieve may save future generations
the time already spent in coming up with the difficult solution. However, in
this case, inheritance may not actually impact problem solving ability, and
thus may be indistinguishable from simply having the first generation continue
problem solving. The second and more interesting mechanism is that inheritance
may change the learning experiences for future generations, which may help
overcome the costs of fixation by beginning problem solving in a unique 
environment.

The uniqueness of the learning environment inherited from previous generations
is the product of the diversity of skills among diachronic problem solvers.
Inheriting a solution created by someone with very similar problem solving
ability (homogenous problem solvers) is unlikely to impact problem solving
beyond what could be achieved by an isolated individual working for the same
total amount of time. In contrast, inheriting a solution created by someone
with very different problem solving ability can introduce a learning environment
that would be impossible to reach by either individual working alone.
**Inheritance is hypothesized to have the largest effect on problem solving
ability when solutions are inherited from heterogenous problem solvers.**

The plausibility of both hypothesis can be demonstrated via artificial
simulations of problem solvers. In these simulations, problem solving is akin
to traversing a solution landscape. A solution landscape is a visualization of
the relationship between variation in possible solutions and resulting solution
success, analogous to fitness landscapes in an evolutionary sense. Problem
solvers traversing a solution landscape seek the highest point in the
landscape. A key intuition generated by these landscapes is that movement
across the landscape is costly, and constrained by current location.

As
the abilities of diachronic problem solvers diverge, subsequent generations
effectively start off in parts of the solution landscape that would have been
unreachable as an isolated individual. For at least some solution landscapes,
diachronic teams with divergent skills are predicted to outperform isolated
individuals, as is demonstrated via artificial simulations below.

## Measuring problem solving ability

I measure problem solving ability as efficiency in completing a set of problems
in a specific amount of time. Other research on problem solving aims to determine
the cognitive abilities that enable the generation of problem solutions. Here
I focus less on whether solutions can be generated and more on how
efficiently progress is achieved. The goal of this research is to measure the
impact of inheritance on problem solving efficiency. Assuming a constant
problem landscape and diachronic problem solvers of equalivant abilities, the impact of inheritance on problem solving is expected to be better fit
by an interactive model than an additive model.

\begin{equation}
problem\ solution = ability \times time = inheritance\\
problem\ solution_{additive} = inheritance + ability \times time\\
problem\ solution_{interactive} = inheritance \times ability \times time\\
\end{equation}

```{r types-of-time}
```

```{r types-of-time-fig, fig.width=6, fig.height=3, fig.cap="**Left.** Relationship between labor hours and calendar hours. Labor hours are being controlled across the strategies, which forces diachronic and synchronic teams to differ in calendar hours. The rate at which labor hours are spent (per calendar hour) is the same for diachronic teams and isolated individuals. **Right.** Differences between teams in terms of time for individual learning. Isolated individuals have the most time for individual learning. The benefits of individual learning are balanced against the potential costs of fatigue and fixation."}
types_of_time_plot
```

# Methods

## Materials and Procedure

Participants played a computer game requiring them to combine items to create
new items (tools), and use those tools to build further tools, all for the sake of
building "a sacred totem to appease the gods." To build a totem, participants
first needed to construct an axe out of three independently discovered items: a
refined stick used as a handle, a sharpened rock for the blade, and string
wound from bark fibers for binding. In the game, more advanced tools
produce larger and more intricate totems, resulting in higher performance
scores.

```{r gameplay, fig.width=6, fig.height=4, fig.cap="The Totems game. **Left.** A sample of the solution landscape. The top row of 6 items are the initial resources available to problem solvers at the start of the experiment. Resources are combined to build the first generation of innovations, including a refined rock, a club derived from an antler, and a small branch of a tree. The first 6 generations of possible innovations are shown. The axe is required to construct the first totem pole. Although the full solution landscape contains more generations of innovations, many participants do not proceed past these 10 innovations in a single 25 minute session. **Right.** Gameplay interface. Participants generated guesses by dragging items into the Workshop and selecting the Try button. If the guess created an item, it could be stored in the Stock panel. Totem segments could be dragged into the Totem panel for scoring."}
grid.arrange(
  read_graphviz_with_images("landscape-sample", "totems"),
  read_image("gameplay", "totems"),
  nrow = 1,
  widths = c(0.35, 0.65)
)
```

## Participants

Participants were recruited until there were at least 40 teams in each strategy.

```{r counts}
```

```{r counts-table, results = "asis"}
kable(condition_counts)
```

# 50 Labor Minutes

```{r team-structures-exp1}
draw_graphviz("team-structures-exp1", "totems")
```

## Number of innovations

```{r num-innovations-50}
```

```{r final-num-innovations-50-fig, fig.height=4, fig.width=8, fig.cap="Total number of innovations discovered by strategy. Each point represents the number of innovations created by a single player in a single session."}
grid.arrange(
  read_graphviz("team-structures-exp1", "totems"),
  final_num_innovations_50_plot,
  nrow = 1,
  widths = c(0.3, 0.7)
)
```

```{r final-num-innovations-50-mod, echo=1, results="asis"}
final_num_innovations_50_mod <- lm(
  NumInnovations ~ DG2_v_DG1 + DG2_v_I50 + DG2_v_IS1 + DG2_v_IS2 + DG2_v_S2,
  data = PlayerPerformance50
)
tidy(final_num_innovations_50_mod) %>%
  kable()
```

## Rate of innovation

```{r num-innovations-over-time-50-fig, fig.width=6, fig.height=10}
grid.arrange(
  types_of_time_plot,
  num_innovations_over_time_50 +
    aes(CalendarTime) +
    scale_x_calendar_time_50 +
    theme(legend.position = c(0.12, 0.75)),
  num_innovations_over_time_50 +
    aes(PlayerTime) +
    scale_x_player_time_50 +
    theme(legend.position = "none"),
  num_innovations_over_time_50 +
    aes(TeamTime) +
    scale_x_team_time_50 +
    theme(legend.position = "none"),
  ncol = 1
)
```

## Comparing generations to repeat sessions

```{r num-innovations-by-generation-50-fig, fig.width=8}
grid.arrange(
  num_innovations_by_generation_50_plot,
  num_unique_innovations_50_plot,
  nrow = 1
)
```

```{r performance-by-generation-50-mod, echo = 1, results = "asis"}
final_num_innovations_by_generation_50_mod <- lmer(
  NumInnovations ~ Diachronic_v_Isolated * Generation + (1|TeamID),
  data = NumInnovationsByGeneration50
)
tidy(final_num_innovations_by_generation_50_mod, effects = "fixed") %>%
  kable()
```

```{r num-additional-innovations-50-mod, echo=1, results="asis"}
num_unique_innovations_50_mod <- lmer(
  UniqueInnovations ~ Diachronic_v_Isolated * Generation + (1|TeamID),
  data = UniqueInnovations50
)
tidy(num_unique_innovations_50_mod, effects = "fixed") %>%
  kable()
```

## Are some inheritances more helpful than others?

```{r inheritance-50}
```

## Likelihood of creating a totem

```{r likelihood-50}
```

```{r likelihood-50-fig}
likelihood50_plot
```

## Guesses

### Total guesses

```{r total-guesses-50}
```

```{r total-guesses-50-fig}
total_guesses_50_plot
```

```{r total-guesses-per-generation-50-fig}
total_guesses_per_generation_50_plot
```

```{r performance-by-total-guesses-50-fig}
performance_by_total_guesses_50_plot
```

```{r performance-by-total-guesses-50-mod, echo = 1, results = "asis"}
performance_by_total_guesses_50_mod <- lm(
  NumInnovations ~ NumGuesses * (DvS + DSvI),
  data = TeamPerformance50
)
tidy(performance_by_total_guesses_50_mod) %>%
  kable()
```

### Unique guesses

```{r unique-guesses-50}
```

```{r unique-guesses-50-fig}
unique_guesses_50_plot
```

```{r unique-guesses-by-total-guesses-50-fig}
unique_guesses_by_total_guesses_50_plot
```

```{r unique-guesses-per-generation-50-fig}
unique_guesses_per_generation_50_plot
```

```{r num-innovations-by-unique-guesses-50-fig}
num_innovations_by_unique_guesses_50_plot
```

### Guess types

```{r types-of-guesses, results = "asis"}
recode_guess_type() %>%
  select(GuessTypeLabel, UniqueGuess, CreatedItem, UniqueResult) %>%
  kable()
```

```{r guess-type-50}
```

```{r prop-redundant-guesses-50-fig}
prop_redundant_guesses_50_plot
```

```{r prop-repeat-items-50-fig}
prop_repeat_items_50_plot
```

```{r prop-unique-guesses-50-fig}
prop_unique_guesses_50_plot
```

```{r prop-guess-types-50-fig}
prop_guess_types_plot
```

```{r prop-guess-types-by-generation-50-fig}
prop_guess_types_by_generation_50_plot
```

## Performance per inventory

```{r performance-per-inventory-50}
```

```{r total-guesses-per-problem-50-fig}
total_guesses_per_problem_50_plot
```

```{r total-guesses-per-problem-50-mod-fig}
total_guesses_per_problem_50_mod_plot
```

```{r total-labor-time-per-problem-50-fig}
total_labor_time_per_problem_50_plot
```

# 100 Labor Minutes

```{r team-structures-exp2}
draw_graphviz("team-structures-exp2", "totems")
```

## Number of innovations

```{r num-innovations-100}
```

```{r final-num-innovations-100-fig, fig.height=4, fig.width=8, fig.cap="Total number of innovations discovered by strategy. Each point represents the number of innovations created by a single player in a single session."}
grid.arrange(
  read_graphviz("team-structures-exp2", "totems"),
  final_num_innovations_100_plot,
  nrow = 1,
  widths = c(0.35, 0.65)
)
```

## Innovation rate

```{r num-innovations-over-time-100-fig, fig.width=6, fig.height=8}
grid.arrange(
  num_innovations_over_time_100 +
    aes(CalendarTime) +
    scale_x_calendar_time_100 +
    theme(legend.position = c(0.12, 0.75)),
  num_innovations_over_time_100 +
    aes(PlayerTime) +
    scale_x_player_time_100 +
    theme(legend.position = "none"),
  num_innovations_over_time_100 +
    aes(TeamTime) +
    scale_x_team_time_100 +
    theme(legend.position = "none"),
  ncol = 1
)
```

## Comparing generations and sessions

```{r num-innovations-by-generation-100-fig, fig.width=8}
grid.arrange(
  num_innovations_by_generation_100_plot,
  num_unique_innovations_100_plot,
  nrow = 1
)
```

# Discussion

# References

---
title: "What is the impact of inheritance on problem solving ability?"
author: "Pierce Edmiston"
csl: "apa.csl"
css: "style.css"
bibliography: "diachronic-collaboration.bib"
output:
  html_document:
    theme: flatly
---

```{r config, include = FALSE}
library(knitr)
library(printr)
opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE,
  results = "hide",
  fig.path = "figs/",
  fig.width = 4,
  fig.height = 3,
  cache = TRUE,
  cache.path = ".cache/"
)
read_chunk("setup.R")
read_chunk("R/types-of-time.R")
```

```{r setup}
```

What is the impact of inheritance on the problem solving ability of individuals? Does inheriting an existing solution to a problem simply give a head start on solving it, or does it actually make for more effective problem solving? To answer this question I consider a simple form of inheritance where one person works on a solution to a problem and then passes it on to another person to continue. Because these two individuals are collaborating over time, I refer to them as **diachronic teams**. To understand the impact of inheritance on problem solving, I compare the problem solving abilities of diachronic teams to two alternative ways of allocating the same number of labor hours: **isolated individuals** working for the same total amount of time, and **synchronic teams** made of two individuals collaborating at the same time (Fig. 1A).

The key condition that enables this comparison is fixing the number of labor hours allowed to each strategy. When labor hours are held constant, diachronic and synchronic teams differ in how many calendar hours they spend on the problem, but diachronic teams do not differ from isolated individuals along this dimension (Fig. 1B). Conversely, diachronic and synchronic teams do not differ in the number of hours committed per team member, but isolated individuals do, having the most time per person (Fig. 1C). By comparing diachronic teams to both isolated individuals and synchronic teams, the effects of inheritance on problem solving ability can be teased apart from these other possible differences between the teams. If inheritance improves problem solving ability, then diachronic teams will outperform these alternative ways of allocating the same number of labor hours.

```{r types-of-time, fig.width=8, fig.align="center", fig.cap="**A.** Three strategies for allocating the same number of labor hours. **B.** By controlling for labor hours, diachronic and synchronic teams differ in calendar hours. **C.** Although isolated individuals spend the most time per person, diachronic and synchronic teams do not differ along this dimension."}
```

# Methods

## Participants

Participants are recruited until the final sample comprises 20 teams in each of the three strategy conditions for a total of 100 participants.

## Materials

Participants are tasked with a tool-building competition presented in a digital environment [@Derex:2015cbb]. Individuals combine resources and build ever more complicated tools in order to build "sacred totems to appease the gods". Individuals achieve high scores by traversing the innovation landscape and developing more and more elaborate ways of cutting, carving, and decorating their totems. A sample of the problem space is presented in Fig. 2.


```{r, cache = FALSE, include = FALSE}
crotchet::read_graphviz_chunk("landscape-sample", package = "totems")
```

```{r landscape-sample, engine = "dot", fig.width = 4, cache = FALSE}
```

## Procedure

```{r}
grid.draw(png::readPNG("../docs/irb/methods/screenshots/gameplay.png") %>% rasterGrob())
```

# Results

```{r, echo = 1:3}
library(totems)
data("totems_players")
data("totems_workshops")

totems_players %<>%
  recode_strategy()

totems_theme <- load_totems_theme()

get_lm_mod_preds <- function(lm_mod) {
  mod_data <- lm_mod$model
  params <- attr(lm_mod$terms, "term.labels")
  x_preds <- unique(mod_data[, params])
  cbind(x_preds, predict(lm_mod, x_preds, se = TRUE))
}
```

## Leaderboards

```{r, echo = 1}
leaderboards <- totems_players %>%
  summarize_team_performance()
```

### Score

```{r score-mod, echo = 1, results = "markup"}
score_mod <- lm(Score ~ Diachronic_v_Synchronic + Diachronic_v_Isolated,
                data = leaderboards)
tidy(score_mod)
```

```{r score-plot}
score_plot <- ggplot(leaderboards) +
  aes(StrategyLabel, Score) +
  geom_point(aes(color = StrategyLabel),
             position = position_jitter(width = 0.3)) +
  geom_bar(aes(fill = StrategyLabel),
           stat = "summary", fun.y = "mean", alpha = 0.6) +
  totems_theme["scale_x_strategy"] +
  totems_theme["scale_color_strategy"] +
  totems_theme["scale_fill_strategy"] +
  totems_theme["base_theme"] +
  theme(legend.position = "none",
        panel.grid.major.x = element_blank())

score_preds <- get_lm_mod_preds(score_mod) %>%
  rename(Score = fit, SE = se.fit) %>%
  recode_strategy()

score_plot +
    geom_linerange(aes(ymin = Score - SE, ymax = Score + SE),
                   data = score_preds)
```

### Number of inventions

```{r inventory-mod, echo = 1, results = "markup"}
inventory_mod <- lm(InventorySize ~ Diachronic_v_Synchronic + Diachronic_v_Isolated,
                    data = leaderboards)
tidy(inventory_mod)
```

```{r inventory-plot}
inventory_plot <- score_plot +
  aes(y = InventorySize) +
  scale_y_continuous("Number of inventions")

inventory_preds <- get_lm_mod_preds(inventory_mod) %>%
  rename(InventorySize = fit, SE = se.fit) %>%
  recode_strategy()

inventory_plot +
  geom_linerange(aes(ymin = InventorySize - SE, ymax = InventorySize + SE),
                 data = inventory_preds)
```

### Difficulty score

```{r difficulty-mod, echo = 1, results = "markup"}
difficulty_mod <- lm(DifficultyScore ~ Diachronic_v_Synchronic + Diachronic_v_Isolated,
                     data = leaderboards)
tidy(difficulty_mod)
```

```{r difficulty-plot}
difficulty_plot <- score_plot +
  aes(y = DifficultyScore) +
  scale_y_continuous("Difficulty score")

difficulty_preds <- get_lm_mod_preds(difficulty_mod) %>%
  rename(DifficultyScore = fit, SE = se.fit) %>%
  recode_strategy()

difficulty_plot +
  geom_linerange(aes(ymin = DifficultyScore - SE, ymax = DifficultyScore + SE),
                 data = difficulty_preds)
```

## Attempts

```{r}
(score_plot %+% totems_players) +
  aes(y = Attempts)
```

```{r ratchets-plot, fig.width=8}
attempts_plot <- ggplot(totems_players) +
  aes(Attempts, Score, color = StrategyLabel) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) +
  totems_theme["scale_color_strategy"] +
  totems_theme["base_theme"] +
  theme(
    legend.position = "none"
  )

grid.arrange(
  attempts_plot,
  attempts_plot +
    aes(y = InventorySize) +
    ylab("Inventory size") +
    theme(
      legend.position = c(0.5, 1),
      legend.direction = "horizontal"
    ),
  attempts_plot +
    aes(y = DifficultyScore) +
    ylab("Difficulty score"),
  nrow = 1
)
```

## Trajectories

```{r}
player_trajectories <- totems_workshops %>%
  group_by(ID_Player, InventorySize, NumAdjacent) %>%
  summarize(Guesses = n()) %>%
  left_join(totems_players %>% select(-InventorySize))

player_ixs <- totems_players %>%
  group_by(ID_Group) %>%
  transmute(IX_Player = 1:n()) %>%
  ungroup()
player_trajectories %<>% left_join(player_ixs)

trajectories <- totems_workshops %>%
  select(InventorySize, NumAdjacent) %>%
  unique()

trajectory_plot <- ggplot() +
  aes(InventorySize, NumAdjacent) +
  geom_point(data = trajectories, color = "gray", alpha = 0.6) +
  geom_point(aes(size = Guesses, color = StrategyLabel)) +
  geom_line(aes(color = StrategyLabel, group = ID_Player)) +
  scale_x_continuous("Inventory size", breaks = c(6, seq(10, 40, by = 5))) +
  totems_theme["scale_color_strategy"] +
  totems_theme["base_theme"] +
  theme(legend.position = "top")

count_teams <- . %>% .$ID_Group %>% unique() %>% length()
n_diachronic_teams <- totems_players %>%
  filter(Strategy == "Diachronic") %>%
  count_teams()
n_synchronic_teams <- totems_players %>%
  filter(Strategy == "Synchronic") %>%
  count_teams()

facet_row_height <- 2
```

```{r trajectories-individual}
trajectory_plot %+% filter(player_trajectories, ID_Player == 12)
```

```{r trajectories-isolated}
(trajectory_plot %+% filter(player_trajectories, Strategy == "Isolated")) +
  scale_color_manual("Strategy", values = totems_theme[["isolated_color"]])
```

```{r trajectories-diachronic, fig.width=6, fig.height=facet_row_height*n_diachronic_teams}
(trajectory_plot %+% filter(player_trajectories, Strategy == "Diachronic")) +
  facet_grid(ID_Group ~ Generation) +
  scale_color_manual("Strategy", values = totems_theme[["diachronic_color"]])
```

```{r trajectories-synchronic, fig.width=6, fig.height=facet_row_height*n_synchronic_teams}
(trajectory_plot %+% filter(player_trajectories, Strategy == "Synchronic")) +
  facet_grid(ID_Group ~ IX_Player) +
  scale_color_manual("Strategy", values = totems_theme[["synchronic_color"]])
```

# Discussion

# References

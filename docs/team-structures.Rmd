---
title: "The impact of team structure on problem solving performance"
author:
  - { name: Pierce Edmiston, affiliation_id: 1 }
  - { name: Maxime Derex, affiliation_id: 2 }
  - { name: Gary Lupyan, affiliation_id: 1 }
affiliation:
  - id: 1
    department: Department of Psychology
    university: University of Wisconsin-Madison
  - id: 2
    department: Biosciences Department
    university: University of Exeter
email: pedmiston\@wisc.edu
address: 1202 W. Johnson St., Department of Psychology, University of Wisconsin, Madison, WI 53703.
abstract: |

bibliography: "references.bib"
csl: "templates/plos-one.csl"
output:
  bookdown::pdf_document2:
    template: templates/plos-one.tmpl
    keep_tex: yes
    number_sections: no
---
```{r team-structures-config, include=FALSE}
library(knitr)
library(crotchet)

opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE,
  results = "hide",

  # PLOS One figure requirements.
  # Width: 789 â€“ 2250 pixels (at 300 dpi). Height maximum: 2625 pixels (at 300 dpi).
  fig.width = 3,
  fig.height = 3,
  dpi = 300,

  cache = TRUE,
  autodep = TRUE
)

# Read all knitr chunks in .R files
chunks_dir <- "R"
read_chunk(file.path(chunks_dir, "team-structures.R"))
```

```{r Setup}
```

# Introduction {-}

```{r Intro}
```

(ref:types-of-time) Team structures controlling for labor time. **Left.** Team structures. Each node is a person. **Middle.** Relationship between labor time and calendar time. Sychronic teams spend labor time more quickly than the other strategies. **Right.** Learning times by strategy, showing that an isolated strategy provides the most time for individual learning.

```{r types-of-time, fig.width=5, fig.height=2, fig.cap="(ref:types-of-time)"}
gridExtra::grid.arrange(
  crotchet::read_graphviz("team-structures", package = "totems"),
  gg_time,
  gg_person,
  nrow = 1,
  widths = c(0.25, 0.375, 0.375)
)
```

# Methods {-}

```{r Methods}
```

## Team structures {-}

Participants were randomly assigned to work on the same problem solving task in
different team structure conditions (Fig. \@ref(fig:team-structures-all)).
Participants in the diachronic condition worked on the problem solving task one
at a time. At the end of a diachronic participant's session, the solutions they
had discovered were passed on to be inherited by a single participant assigned
to the next generation of the same team.

Participants assigned to the synchronic team structure worked independently and
in parallel. Their labor was coordinated in that solutions discovered by one
team member were immediately shared with the other members of the team via the
computer interface.

Isolated participants completed the problem solving task as individuals, only
benefiting from the solutions they could discover on their own. Isolated participants
completed the experiment in a single 50 minute session or came back for four 25
minute sessions scheduled with at least one full day between subsequent sessions.

(ref:team-structures-all) All team structure conditions. Participants assigned
to the diachronic condition worked one at a time, each inheriting the solutions
discovered by the previous generation. Participants in the isolated condition
were recruited for a single 50 minute session, or returned for four 25 minute
sessions. Participants assigned to synchronic teams worked for 25 minutes
in teams of two or four individuals.

```{r team-structures-all, out.width="50%", fig.cap='(ref:team-structures-all)'}
crotchet::draw_graphviz("team-structures-all", package = "totems")
```

## Problem solving task {-}

Participants played the "Totems" game adapted from @Derex:2015cbb. Their task
was to discover how to build tools with the ultimate goal of creating "a sacred
totem to appease the gods." To build a totem, participants first needed to
construct an axe out of three independently discovered tools: a refined stick
used as a handle, a sharpened rock for the blade, and a string wound from bark
fibers for binding (Fig. \@ref(fig:landscape-sample)). More advanced tools
produce larger and more intricate totems, resulting in higher performance
scores.

Participants discovered new tools by combining existing items. Participants
could combine up to four items at a time (with replacement), meaning the
initial six items could form a total of `r methods$n_unique_combinations_6`
combinations. Of all possible combinations, very few resulted in new items. For
example, of all the guesses that could be formed from the initial items, only
three (`r methods$n_unique_combinations_6_pct`%) yielded new tools (Fig.
\@ref(fig:landscape-sample)). As participants accumulate solutions, the
combinatorial complexity of the problem space increased exponentially such that
the discovery of more complex tools is less likely to happen by chance.

(ref:landscape-sample) A sample of the solution landscape. The top row of 6
items were available to problem solvers at the start of the game. New items
could be produced through the combination of different items (more than one
arrow points to the item) or through the refinement of a single item (a single
arrow points to the item). The axe is required to construct the first totem
pole.

```{r landscape-sample, fig.height=4, fig.cap="(ref:landscape-sample)"}
draw_image("landscape-sample.gv", package = "totems")
```

Once a tool was discovered, the recipe for its creation---a list of the items
that had to be combined in order to create the tool---was recorded in an
innovation record (Fig. \@ref(fig:interface)). Participants could review their
past innovations and see the recipes for their previous discoveries.

The innovation record was also used as the means for sharing solutions among
members of a team. For diachronic participants after the first generation, the
innovation record from the previous generation participant was made available
to them from the start of the experiment. They could view their predecessors'
innovation record and see how to make each one.

Note that the participants inherited the recipes for creating the tools, and not
the tools themselves. In order use these tools in further combinations, the
tools and all of their constituent parts first had to be recreated.

Participants assigned to the synchronic condition could see the
innovation records of each of their teammates throughout the session. Once a
participant discovered a tool, the recipe for its creation could be viewed by
all members of the team.

Isolated participants returning for multiple sessions started with
the innovation record from their previous session. As was true for
participants in the diachronic and synchronic conditions, recipes
inherited via the innovation record had to be recreated in order to
be used in future combinations.

(ref:interface) The Totems gameplay interface. Participants generated guesses
by dragging items into the Workshop and selecting the Try button. If the guess
created an item, it could be dragged into the Stock panel, and used again. Once
segments of a totem were made through cutting, carving, and painting, they could be dragged into the Totem panel for scoring.

```{r interface, fig.cap="(ref:interface)", out.width="100%"}
draw_image("gameplay", "totems")
```

## Participants {-}

Participants were undergraduate students at the University of Wisconsin-Madison
who completed the experiment in exchange for course credit. Students received
credit based on the duration of each completed session. Sessions were either 25
minutes or 50 minutes. Participants assigned to the Isolated, multi-session
condition who completed all four sessions were awarded additional credit.

(ref:condition-counts) Total participant and team recruitment.

```{r counts-table, results="asis"}
kable(ConditionCounts, caption = "(ref:condition-counts)")
```

# Experiment 1 {-}

```{r 50min}
```

In Experiment 1, we compared the simplest form of diachronic inheritance---a
two-person diachronic team---to two alternative strategies for allocating the
same 50 minutes of labor: isolated individuals working alone and two-person
synchronic teams (Fig. \@ref(fig:team-structures-50min)). We first report
differences between strategies in terms of final team performance.

## Methods {-}

(ref:team-structures-50min) Problem solving strategies compared in Experiment 1.

```{r team-structures-50min, out.width="30%", fig.cap="(ref:team-structures-50min)"}
crotchet::draw_graphviz("team-structures-50min", package = "totems")
```

## Results {-}

### Innovations {-}

The number of innovations discovered using each of the three team strategies
is shown in Fig. \@ref(fig:innovations-50min). Our primary hypothesis concerned
the effectiveness of a diachronic strategy as compared to alternative strategies
for allocating the same number of labor hours. The results show that when
controlling for labor hours, diachronic teams did not result in significantly
different performance than the alternative strategies. Diachronic teams
discovered more innovations on average than isolated individuals, but post
hoc tests revealed that this difference was not statistically significant,
`r exp1$DG2_v_I50`. Conversely, diachronic teams discovered fewer innovations
on average than two-person synchronic teams, but again this difference was
not statistically significant, `r exp1$S2_v_DG2`. This result speaks to the
importance of controlling for labor hours when trying to understand the
impact of teammwork on problem solving.

To test the effectiveness of teamwork as opposed to individual labor,
we compared two-person teams (both diachronic and synchronic) to
isolated individuals. We found a benefit to teamwork in this task,
`r exp1$teamwork_stats`, with no residual difference between diachronic and
synchronic strategies, `r exp1$teamwork_residual`. Post hoc tests revealed that
this effect of teamwork was driven primarily by synchronic teams outperforming
isolated individuals, `r exp1$S2_v_I50`. This result suggests that maximizing
individual learning time is not always the most effective way of improving
problem solving performance.

(ref:innovations-50min) Innovations discovered in 50 labor minutes by strategy. **A.**
Rate of innovation by labor hours. **B.** Final innovations by strategy. Bars with
errors show model predictions with Â±1 standard error.

```{r innovations-50min, fig.width=5, fig.height=3, fig.cap="(ref:innovations-50min)"}
grid.arrange(
  innovation_rate_50min_plot + ggtitle("A"),
  num_innovations_50min_plot + ggtitle("B"),
  nrow = 1,
  widths = c(0.55, 0.45)
)
```

### Guesses per innovation {-}

We compared the three strategies in terms of how many guesses were required to
discover each new innovation. To count the number of guesses that were required
for each innovation, we tallied all guesses made from the moment in which a new
item was eligible for discovery until that item was discovered. A new item was
eligible for discovery once all of the items required to create the new item had
been discovered. New items that are eligible for discovery are referred to as
adjacent items, since they are adjacent to the current inventory in the
overall problem space. The minimum number of adjacent items for an inventory
was one, indicating that there was a single innovation that must be discovered
before new items can be created. The median number of adjacent items was four.
When there was more than one adjacent item, each guess counted toward the total
number of guesses for each of the adjacent items not created by the guess.

We found that diachronic inheritance did reduce the total number of guesses
made for each new item relative to the same items being guessed with an
isolated and synchronic strategy (Fig. \@ref(fig:guesses-per-item)A). However,
we found that this overall benefit to inheritance in terms of fewer guesses
per item did not extend to items that had not been discovered by the previous
generation. Comparing the number of guesses per item only for items that
were newly discovered by the second generation diachronic problem solvers
did not reveal a benefit to inheritance (Fig. \@ref(fig:guesses-per-item)B).

(ref:guesses-per-innovation) Average guesses per innovation.

```{r guesses-per-innovation, fig.width=5}
guesses_per_item_treatment_plot
```

### Guessing strategy {-}

Finally we investigated the guessing strategy employed in each strategy.
We were interested in whether inheritance caused second generation
diachronic problem solvers to guess differently than players in
the other strategies.

Our results are shown in Fig. \@ref(fig:guess-types).

```{r guess-types, fig.width=5}
prop_guess_types_50min_plot
```

## Discussion {-}

In Experiment 1, we found that inheriting from a previous generation problem solver
is comparable to alternative strategies for solving the same set of problems. Two
generations of problem solvers working for 25 minutes each results in similar final
performance to an isolated individual given 50 minutes and two problem solvers
working in parallel for 25 minutes each.

We detected the effects of inheriting from a previous generation in the guessing efficiency
and guessing strategies employed by diachronic problem solvers. Inheriting the solutions
from a previous generation improved the efficiency of future generations of problem solvers
by allowing them to recreate those same items with fewer guesses overall. However, this
improvement in efficiency did not extend to future problem solving, as second generation
diachronic problem solvers were not any more efficient in solving problems that had not
been discovered by their ancestor.

Second generation diachronic players did seem to employ a different guessing strategy
as reflected in the distribution of guesses by type. In this game, redundant guesses
are unhelpful in that they will never yield new discoveries, and yet most participants
generate a significant proportion of redundant guesses. This detrimental tendency to guess
redundantly may be is lessened by diachronic collaboration, as second generation diachronic
problem solvers generated fewer redundant guesses than their ancestors. However, similar
proportions of redundant guesses were generated by participants in the synchronic strategy
as well.

# Experiment 2 {-}

```{r SelfOther}
```

In Experiment 2, we compare the effectiveness of inheriting from someone else to
the effectiveness of inheriting from yourself (Fig. \@ref(fig:team-structures-selfother).
In this experiment, participants were assigned to the diachronic condition or
the isolated condition. Participants in the isolated condition were asked to
come back to the experiment for four separate sessions, each 25 minutes long. At
each session after the first, these participants inherited the recipes for the
tools they had created at the end of the previous session.

## Methods {-}

(ref:team-structures-selfother) Problem solving strategies compared in Experiment 2.

```{r team-structures-selfother, out.width="70%", fig.cap="(ref:team-structures-selfother)"}
crotchet::draw_graphviz("team-structures-selfother", package = "totems")
```

## Results {-}

```{r innovations-by-generation-selfother}
innovations_by_generation_plot
```

```{r cost-of-first-innovation}
first_discovery_by_generation_plot
```

## Discussion {-}

# Experiment 3 {-}

```{r TeamSize}
```

## Methods {-}

(ref:team-structures-scalability) Problem solving strategies compared in Experiment 3.

```{r team-structures-scalability, out.width="80%", fig.cap="(ref:team-structures-scalability)"}
crotchet::draw_graphviz("team-structures-scalability", package = "totems")
```

## Results {-}

```{r max-innovations-by-teamsize, fig.width=5}
max_innovations_by_teamsize_plot
```

```{r bots-teamsize, fig.width=5}
bots_team_size_plot
```

## Discussion {-}

# General Discussion {-}

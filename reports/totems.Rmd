---
title: "What is the impact of inheritance on problem solving ability?"
author: "Pierce Edmiston"
csl: "../docs/apa.csl"
bibliography: "../docs/diachronic-collaboration.bib"
output:
  html_document:
    theme: flatly
---

```{r config, include = FALSE}
library(knitr)
opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE,
  results = "hide",
  fig.path = "figs/",
  fig.width = 6,
  fig.height = 3,
  cache = TRUE,
  cache.path = ".cache/"
)
read_chunk("setup.R")
```

```{r setup}
```

What is the impact of inheritance on the problem solving ability of individuals? Does inheriting an existing solution to a problem simply give a head start on solving it, or does it actually make for more effective problem solving? To answer this question I consider a simple form of inheritance where one person works on a solution to a problem and then passes it on to another person to continue. Because these two individuals are working on the same problem cooperatively, I refer to them as **diachronic teams** (Fig. 1A). To understand the impact of inheritance on problem solving, I compare the problem solving efficiency of diachronic teams organized around inheritance to two alternative ways of allocating the same number of labor hours: **isolated individuals** working for the same total amount of time, and **synchronic teams** working in parallel.

The key condition that is controlled in this comparison is the number of labor hours allotted to each team. When labor hours are held constant, the dimension along which diachronic and synchronic teams differ is that diachronic teams “spend” labor hours more slowly than synchronic teams (Fig. 1B). By spending labor hours more slowly, diachronic teams maximize the extent to which each team member can inherit and modify existing solutions to the problem. Although teams working in parallel are also able to share solutions among members and thus exhibit some form of inheritance, diachronic teams maximize this dimension of inheritance. If inheritance improves problem solving efficiency, then diachronic teams by maximizing inheritance will outperform alternative ways of allocating the same number of labor hours.

In addition to comparing diachronic teams to synchronic teams, a third condition considered is an isolated individual working for the same number of labor hours (Fig. 1A). Isolated individuals also “spend” labor hours more slowly than synchronic teams at exactly the rate of diachronic teams (Fig. 1B). However, isolated individuals are only maximizing the inheritance of their own past solutions. To the extent that inheriting an existing solution created by someone else improves problem solving ability, diachronic teams will outperform isolated individuals.

```{r fig1}
diachronic <- data_frame(
  Strategy = "Diachronic",
  CalendarHours = 0:100,
  LaborHours = CalendarHours
)

isolated <- diachronic %>% mutate(Strategy = "Isolated")

synchronic <- data_frame(
  Strategy = "Synchronic",
  CalendarHours = 0:50,
  LaborHours = CalendarHours * 2
)

time <- rbind(diachronic, synchronic, isolated) %>%
  recode_strategy()

axis_breaks <- c(0, 50, 100)
axis_labels <- c(0, expression(1/2), 1)

gg_time <- ggplot(time, aes(CalendarHours, LaborHours)) +
  geom_line(aes(color = StrategyLabel, lty = StrategyLabel), size = 1.2) +
  scale_x_continuous("Calendar hours", breaks = axis_breaks, labels = axis_labels) +
  scale_y_continuous("Labor hours", breaks = axis_breaks, labels = axis_labels) +
  scale_color_strategy +
  scale_linetype_manual(values = c(1, 1, 2)) +
  guides(color = guide_legend(""), linetype = "none") +
  base_theme +
  theme(legend.position = "top")

grid.arrange(
  read_graphviz("team-structures-all", package = "evoteams"),
  gg_time,
  nrow = 1
)
```

# Methods

## Participants

Participants are recruited until the final sample comprises 20 teams in each of the three strategy conditions for a total of 100 participants.

## Materials

Participants are tasked with a tool-building competition presented in a digital environment [@Derex:2015cbb]. Individuals combine resources and build ever more complicated tools in order to build "sacred totems to appease the gods". Individuals achieve high scores by traversing the innovation landscape and developing more and more elaborate ways of cutting, carving, and decorating their totems. A sample of the problem space is presented in Fig. 2. 


```{r, cache = FALSE, include = FALSE}
crotchet::read_graphviz_chunk("landscape-sample", package = "evoteams")
```

```{r landscape-sample, engine = "dot", fig.width = 4, cache = FALSE}
```

## Procedure

```{r}
grid.draw(png::readPNG("../docs/irb/methods/screenshots/gameplay.png") %>% rasterGrob())
```

# Results

```{r, include = FALSE}
data("totems_player")
```

## Leaderboards

```{r, echo = 1:2, eval = FALSE}
score_mod <- lm(Score ~ Diachronic_v_Synchronic + Diachronic_v_Isolated,
                data = filter_final_scores(totems_player))
tidy(score_mod)
```

```{r}
ggplot(filter_final_score(totems_player)) +
  aes(StrategyLabel, Score) +
  geom_point(aes(color = StrategyLabel),
             position = position_jitter(width = 0.3)) +
  geom_bar(aes(fill = StrategyLabel), stat = "summary", fun.y = "mean",
           alpha = 0.6) +
  scale_x_strategy +
  scale_color_strategy +
  scale_fill_strategy +
  base_theme +
  theme(legend.position = "none",
        panel.grid.major.x = element_blank())
```

## Strategy

# Discussion

# References
